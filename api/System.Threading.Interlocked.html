<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Class Interlocked
   | CoreCLR site </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Class Interlocked
   | CoreCLR site ">
    
    <link rel="shortcut icon" href="../images/Logo_DotNet.png" type="image/x-icon">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/main.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/style.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  
    ga('create', 'UA-63735192-1', 'auto');
    ga('send', 'pageview');
    </script>
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav class="navbar navbar-inverse">
             <div class="container">
               <a href="../"><img height="50px" src="../images/Logo_DotNet.png" style="float:right;"></a>
               <div class="navbar-header ">
                 <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                   <span class="sr-only">Toggle navigation</span>
                   <span class="icon-bar"></span>
                   <span class="icon-bar"></span>
                   <span class="icon-bar"></span>
                 </button>
                 <a class="navbar-brand" href="../"><span class="dotnet">.NET Core</span></a>
               </div>
               <div id="navbar" class="collapse navbar-collapse">
               </div><!--/.nav-collapse -->
             </div>
           </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content">
              
              <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A" class="pull-right mobile-hide"><span class="fa fa-github"></span>Improve this Doc</a>
              <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/Interlocked.cs/#L20" class="pull-right mobile-hide">View Source</a>
              <h1 id="System_Threading_Interlocked" data-uid="System.Threading.Interlocked">Class Interlocked
              </h1>
              <div class="markdown level0 summary"><p>Provides atomic operations for variables that are shared by multiple threads. </p>
</div>
              <div class="markdown level0 conceptual"></div>
              <div class="inheritance">
                <h5>Inheritance</h5>
                  <div class="level0"><a class="xref" href="System.Object.html#System_Object">Object</a></div>
                  <div class="level1"><span class="xref">Interlocked</span></div>
              </div>
              <div class="inheritedMembers">
                <h5>Inherited Members</h5>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_ToString">ToString()</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_Equals_System_Object_">Equals(Object)</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_Equals_System_Object_System_Object_">Equals(Object, Object)</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_ReferenceEquals_System_Object_System_Object_">ReferenceEquals(Object, Object)</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_GetHashCode">GetHashCode()</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_GetType">GetType()</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_MemberwiseClone">MemberwiseClone()</a>
                </div>
              </div>
              <h6><strong>Namespace</strong>:System.Threading</h6>
              <h6><strong>Assembly</strong>:System.Threading.dll</h6>
              <h5 id="System_Threading_Interlocked_syntax">Syntax</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public class Interlocked</code></pre>
              </div>
              <h5 id="System_Threading_Interlocked_examples"><strong>Examples</strong></h5>
              
<p>The following code example shows a thread-safe resource locking mechanism.</p>System.Threading.Interlocked.Exchange Int32 Example#1
              <h3 id="methods">Methods
              </h3>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked_Add_System_Int32__System_Int32_.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked.Add(System.Int32%40%2CSystem.Int32)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/Interlocked.cs/#L207">View Source</a>
              </span>
              <h4 id="System_Threading_Interlocked_Add_System_Int32__System_Int32_" data-uid="System.Threading.Interlocked.Add(System.Int32@,System.Int32)">Add(ref Int32, Int32)</h4>
              <div class="markdown level1 summary"><p>Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Interlocked_Add_System_Int32__System_Int32__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method handles an overflow condition by wrapping: if the value at <em>location1</em> is <a class="xref" href="System.Int32.html#System_Int32_MaxValue">MaxValue</a> and <em>value</em> is 1, the result is <a class="xref" href="System.Int32.html#System_Int32_MinValue">MinValue</a>; if <em>value</em> is 2, the result is (<a class="xref" href="System.Int32.html#System_Int32_MinValue">MinValue</a> + 1); and so on. No exception is thrown.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
public static int Add(ref int location1, int value)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td><em>location1</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td><em>value</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Interlocked_Add_System_Int32__System_Int32__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method handles an overflow condition by wrapping: if the value at <em>location1</em> is <a class="xref" href="System.Int32.html#System_Int32_MaxValue">MaxValue</a> and <em>value</em> is 1, the result is <a class="xref" href="System.Int32.html#System_Int32_MinValue">MinValue</a>; if <em>value</em> is 2, the result is (<a class="xref" href="System.Int32.html#System_Int32_MinValue">MinValue</a> + 1); and so on. No exception is thrown.</p>
</div>
              
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.NullReferenceException.html#System_NullReferenceException">NullReferenceException</a></td>
                    <td><p>The address of <em>location1</em> is a null pointer. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked_Add_System_Int64__System_Int64_.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked.Add(System.Int64%40%2CSystem.Int64)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/Interlocked.cs/#L213">View Source</a>
              </span>
              <h4 id="System_Threading_Interlocked_Add_System_Int64__System_Int64_" data-uid="System.Threading.Interlocked.Add(System.Int64@,System.Int64)">Add(ref Int64, Int64)</h4>
              <div class="markdown level1 summary"><p>Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Interlocked_Add_System_Int64__System_Int64__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method handles an overflow condition by wrapping: if the value at <em>location1</em> is <a class="xref" href="System.Int64.html#System_Int64_MaxValue">MaxValue</a> and <em>value</em> is 1, the result is <a class="xref" href="System.Int64.html#System_Int64_MinValue">MinValue</a>; if <em>value</em> is 2, the result is (<a class="xref" href="System.Int64.html#System_Int64_MinValue">MinValue</a> + 1); and so on. No exception is thrown.</p>
<p>The <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_Read_System_Int64__">Read(ref Int64)</a> method and the 64-bit overloads of the <see cref="Overload:System.Threading.Interlocked.Increment"></see>, <see cref="Overload:System.Threading.Interlocked.Decrement"></see>, and <see cref="Overload:System.Threading.Interlocked.Add"></see> methods are truly atomic only on systems where a <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked">Interlocked</a> class.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
public static long Add(ref long location1, long value)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int64.html#System_Int64">Int64</a></td>
                    <td><em>location1</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Int64.html#System_Int64">Int64</a></td>
                    <td><em>value</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int64.html#System_Int64">Int64</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Interlocked_Add_System_Int64__System_Int64__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method handles an overflow condition by wrapping: if the value at <em>location1</em> is <a class="xref" href="System.Int64.html#System_Int64_MaxValue">MaxValue</a> and <em>value</em> is 1, the result is <a class="xref" href="System.Int64.html#System_Int64_MinValue">MinValue</a>; if <em>value</em> is 2, the result is (<a class="xref" href="System.Int64.html#System_Int64_MinValue">MinValue</a> + 1); and so on. No exception is thrown.</p>
<p>The <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_Read_System_Int64__">Read(ref Int64)</a> method and the 64-bit overloads of the <see cref="Overload:System.Threading.Interlocked.Increment"></see>, <see cref="Overload:System.Threading.Interlocked.Decrement"></see>, and <see cref="Overload:System.Threading.Interlocked.Add"></see> methods are truly atomic only on systems where a <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked">Interlocked</a> class.</p>
</div>
              
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.NullReferenceException.html#System_NullReferenceException">NullReferenceException</a></td>
                    <td><p>The address of <em>location1</em> is a null pointer. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked_CompareExchange_System_Double__System_Double_System_Double_.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked.CompareExchange(System.Double%40%2CSystem.Double%2CSystem.Double)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              
              <h4 id="System_Threading_Interlocked_CompareExchange_System_Double__System_Double_System_Double_" data-uid="System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">CompareExchange(ref Double, Double, Double)</h4>
              <div class="markdown level1 summary"><p>Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Interlocked_CompareExchange_System_Double__System_Double_System_Double__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>comparand</em> and the value in <em>location1</em> are equal, then <em>value</em> is stored in <em>location1</em>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <see cref="Overload:System.Threading.Interlocked.CompareExchange"></see> is the original value in <em>location1</em>, whether or not the exchange takes place.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[MethodImpl(MethodImplOptions.InternalCall)]
[SecuritySafeCritical]
public static double CompareExchange(ref double location1, double value, double comparand)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Double.html#System_Double">Double</a></td>
                    <td><em>location1</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Double.html#System_Double">Double</a></td>
                    <td><em>value</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Double.html#System_Double">Double</a></td>
                    <td><em>comparand</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Double.html#System_Double">Double</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Interlocked_CompareExchange_System_Double__System_Double_System_Double__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>comparand</em> and the value in <em>location1</em> are equal, then <em>value</em> is stored in <em>location1</em>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <see cref="Overload:System.Threading.Interlocked.CompareExchange"></see> is the original value in <em>location1</em>, whether or not the exchange takes place.</p>
</div>
              <h5 id="System_Threading_Interlocked_CompareExchange_System_Double__System_Double_System_Double__examples">Examples</h5>
              
<p>The following code example demonstrates a thread-safe method that accumulates a running total of <a class="xref" href="System.Double.html#System_Double">Double</a> values. Two threads add a series of <a class="xref" href="System.Double.html#System_Double">Double</a> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared. On a dual-processor computer, there is a significant difference in the totals. </p>
<p>In the thread-safe method, the initial value of the running total is saved, and then the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_CompareExchange_System_Double__System_Double_System_Double_">CompareExchange(ref Double, Double, Double)</a> method is used to exchange the newly computed total with the old total. If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime. In that case, the attempt to update the running total must be repeated.</p>System.Threading.Interlocked CompareExchange Double#1
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.NullReferenceException.html#System_NullReferenceException">NullReferenceException</a></td>
                    <td><p>The address of <em>location1</em> is a null pointer. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked_CompareExchange_System_Int32__System_Int32_System_Int32_.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked.CompareExchange(System.Int32%40%2CSystem.Int32%2CSystem.Int32)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              
              <h4 id="System_Threading_Interlocked_CompareExchange_System_Int32__System_Int32_System_Int32_" data-uid="System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">CompareExchange(ref Int32, Int32, Int32)</h4>
              <div class="markdown level1 summary"><p>Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Interlocked_CompareExchange_System_Int32__System_Int32_System_Int32__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>comparand</em> and the value in <em>location1</em> are equal, then <em>value</em> is stored in <em>location1</em>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <see cref="Overload:System.Threading.Interlocked.CompareExchange"></see> is the original value in <em>location1</em>, whether or not the exchange takes place.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[MethodImpl(MethodImplOptions.InternalCall)]
[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
[SecuritySafeCritical]
public static int CompareExchange(ref int location1, int value, int comparand)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td><em>location1</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td><em>value</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td><em>comparand</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Interlocked_CompareExchange_System_Int32__System_Int32_System_Int32__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>comparand</em> and the value in <em>location1</em> are equal, then <em>value</em> is stored in <em>location1</em>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <see cref="Overload:System.Threading.Interlocked.CompareExchange"></see> is the original value in <em>location1</em>, whether or not the exchange takes place.</p>
</div>
              <h5 id="System_Threading_Interlocked_CompareExchange_System_Int32__System_Int32_System_Int32__examples">Examples</h5>
              
<p>The following code example demonstrates a thread-safe method that accumulates a running total. The initial value of the running total is saved, and then the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_CompareExchange_System_Int32__System_Int32_System_Int32_">CompareExchange(ref Int32, Int32, Int32)</a> method is used to exchange the newly computed total with the old total. If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime. In that case, the attempt to update the running total must be repeated.</p>
<p>The <see cref="Overload:System.Threading.Interlocked.Add"></see> method, introduced in version 2.0 of the .NET Framework, provides a more convenient way to accumulate thread-safe running totals for integers.</p>System.Threading.Interlocked CompareExchange0#1
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.NullReferenceException.html#System_NullReferenceException">NullReferenceException</a></td>
                    <td><p>The address of <em>location1</em> is a null pointer. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked_CompareExchange_System_Int64__System_Int64_System_Int64_.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked.CompareExchange(System.Int64%40%2CSystem.Int64%2CSystem.Int64)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              
              <h4 id="System_Threading_Interlocked_CompareExchange_System_Int64__System_Int64_System_Int64_" data-uid="System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">CompareExchange(ref Int64, Int64, Int64)</h4>
              <div class="markdown level1 summary"><p>Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Interlocked_CompareExchange_System_Int64__System_Int64_System_Int64__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>comparand</em> and the value in <em>location1</em> are equal, then <em>value</em> is stored in <em>location1</em>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <see cref="Overload:System.Threading.Interlocked.CompareExchange"></see> is the original value in <em>location1</em>, whether or not the exchange takes place.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[MethodImpl(MethodImplOptions.InternalCall)]
[SecuritySafeCritical]
public static long CompareExchange(ref long location1, long value, long comparand)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int64.html#System_Int64">Int64</a></td>
                    <td><em>location1</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Int64.html#System_Int64">Int64</a></td>
                    <td><em>value</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Int64.html#System_Int64">Int64</a></td>
                    <td><em>comparand</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int64.html#System_Int64">Int64</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Interlocked_CompareExchange_System_Int64__System_Int64_System_Int64__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>comparand</em> and the value in <em>location1</em> are equal, then <em>value</em> is stored in <em>location1</em>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <see cref="Overload:System.Threading.Interlocked.CompareExchange"></see> is the original value in <em>location1</em>, whether or not the exchange takes place.</p>
</div>
              
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.NullReferenceException.html#System_NullReferenceException">NullReferenceException</a></td>
                    <td><p>The address of <em>location1</em> is a null pointer. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked_CompareExchange_System_IntPtr__System_IntPtr_System_IntPtr_.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked.CompareExchange(System.IntPtr%40%2CSystem.IntPtr%2CSystem.IntPtr)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              
              <h4 id="System_Threading_Interlocked_CompareExchange_System_IntPtr__System_IntPtr_System_IntPtr_" data-uid="System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">CompareExchange(ref IntPtr, IntPtr, IntPtr)</h4>
              <div class="markdown level1 summary"><p>Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Interlocked_CompareExchange_System_IntPtr__System_IntPtr_System_IntPtr__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>comparand</em> and the value in <em>location1</em> are equal, then <em>value</em> is stored in <em>location1</em>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of this method is the original value in <em>location1</em>, whether or not the exchange takes place.</p>
<p>
<a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> is a platform-specific type.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[MethodImpl(MethodImplOptions.InternalCall)]
[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
[SecuritySafeCritical]
public static IntPtr CompareExchange(ref IntPtr location1, IntPtr value, IntPtr comparand)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a></td>
                    <td><em>location1</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a></td>
                    <td><em>value</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a></td>
                    <td><em>comparand</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Interlocked_CompareExchange_System_IntPtr__System_IntPtr_System_IntPtr__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>comparand</em> and the value in <em>location1</em> are equal, then <em>value</em> is stored in <em>location1</em>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of this method is the original value in <em>location1</em>, whether or not the exchange takes place.</p>
<p>
<a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> is a platform-specific type.</p>
</div>
              <h5 id="System_Threading_Interlocked_CompareExchange_System_IntPtr__System_IntPtr_System_IntPtr__examples">Examples</h5>
              
<p>The following code example shows a thread-safe resource locking mechanism.</p>System.Threading.Interlocked.Exchange Int32 Example#1
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.NullReferenceException.html#System_NullReferenceException">NullReferenceException</a></td>
                    <td><p>The address of <em>location1</em> is a null pointer. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked_CompareExchange_System_Object__System_Object_System_Object_.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked.CompareExchange(System.Object%40%2CSystem.Object%2CSystem.Object)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              
              <h4 id="System_Threading_Interlocked_CompareExchange_System_Object__System_Object_System_Object_" data-uid="System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">CompareExchange(ref Object, Object, Object)</h4>
              <div class="markdown level1 summary"><p>Compares two objects for reference equality and, if they are equal, replaces the first object.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Interlocked_CompareExchange_System_Object__System_Object_System_Object__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>comparand</em> and the object in <em>location1</em> are equal, then <em>value</em> is stored in <em>location1</em>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <see cref="Overload:System.Threading.Interlocked.CompareExchange"></see> is the original value in <em>location1</em>, whether or not the exchange takes place.</p>
<p>Beginning with .NET Framework version 2.0, the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_CompareExchange__1___0____0___0_">CompareExchange<t>(ref T, T, T)</t></a> method overload provides a type-safe alternative for reference types.</p>
<p>The objects are compared for reference equality, rather than <a class="xref" href="System.Object.html#System_Object_Equals_System_Object_">Equals(Object)</a>. As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal, and no operation is performed. Do not use this overload with value types.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[MethodImpl(MethodImplOptions.InternalCall)]
[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
[SecuritySafeCritical]
public static object CompareExchange(ref object location1, object value, object comparand)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Object.html#System_Object">Object</a></td>
                    <td><em>location1</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Object.html#System_Object">Object</a></td>
                    <td><em>value</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Object.html#System_Object">Object</a></td>
                    <td><em>comparand</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Object.html#System_Object">Object</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Interlocked_CompareExchange_System_Object__System_Object_System_Object__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>comparand</em> and the object in <em>location1</em> are equal, then <em>value</em> is stored in <em>location1</em>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <see cref="Overload:System.Threading.Interlocked.CompareExchange"></see> is the original value in <em>location1</em>, whether or not the exchange takes place.</p>
<p>Beginning with .NET Framework version 2.0, the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_CompareExchange__1___0____0___0_">CompareExchange<t>(ref T, T, T)</t></a> method overload provides a type-safe alternative for reference types.</p>
<p>The objects are compared for reference equality, rather than <a class="xref" href="System.Object.html#System_Object_Equals_System_Object_">Equals(Object)</a>. As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal, and no operation is performed. Do not use this overload with value types.</p>
</div>
              <h5 id="System_Threading_Interlocked_CompareExchange_System_Object__System_Object_System_Object__examples">Examples</h5>
              
<p>The following code example shows a thread-safe resource locking mechanism.</p>System.Threading.Interlocked.Exchange Int32 Example#1
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.ArgumentNullException.html#System_ArgumentNullException">ArgumentNullException</a></td>
                    <td><p>The address of <em>location1</em> is a null pointer. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked_CompareExchange_System_Single__System_Single_System_Single_.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked.CompareExchange(System.Single%40%2CSystem.Single%2CSystem.Single)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              
              <h4 id="System_Threading_Interlocked_CompareExchange_System_Single__System_Single_System_Single_" data-uid="System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">CompareExchange(ref Single, Single, Single)</h4>
              <div class="markdown level1 summary"><p>Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Interlocked_CompareExchange_System_Single__System_Single_System_Single__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>comparand</em> and the value in <em>location1</em> are equal, then <em>value</em> is stored in <em>location1</em>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <see cref="Overload:System.Threading.Interlocked.CompareExchange"></see> is the original value in <em>location1</em>, whether or not the exchange takes place.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[MethodImpl(MethodImplOptions.InternalCall)]
[SecuritySafeCritical]
public static float CompareExchange(ref float location1, float value, float comparand)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Single.html#System_Single">Single</a></td>
                    <td><em>location1</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Single.html#System_Single">Single</a></td>
                    <td><em>value</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Single.html#System_Single">Single</a></td>
                    <td><em>comparand</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Single.html#System_Single">Single</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Interlocked_CompareExchange_System_Single__System_Single_System_Single__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>comparand</em> and the value in <em>location1</em> are equal, then <em>value</em> is stored in <em>location1</em>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <see cref="Overload:System.Threading.Interlocked.CompareExchange"></see> is the original value in <em>location1</em>, whether or not the exchange takes place.</p>
</div>
              <h5 id="System_Threading_Interlocked_CompareExchange_System_Single__System_Single_System_Single__examples">Examples</h5>
              
<p>The following code example demonstrates a thread-safe method that accumulates a running total of <a class="xref" href="System.Single.html#System_Single">Single</a> values. Two threads add a series of <a class="xref" href="System.Single.html#System_Single">Single</a> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared. On a dual-processor computer, there is a significant difference in the totals. </p>
<p>In the thread-safe method, the initial value of the running total is saved, and then the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_CompareExchange_System_Single__System_Single_System_Single_">CompareExchange(ref Single, Single, Single)</a> method is used to exchange the newly computed total with the old total. If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime. In that case, the attempt to update the running total must be repeated.</p>System.Threading.Interlocked CompareExchange Single#1
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.NullReferenceException.html#System_NullReferenceException">NullReferenceException</a></td>
                    <td><p>The address of <em>location1</em> is a null pointer. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked_CompareExchange__1___0____0___0_.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked.CompareExchange%60%601(%60%600%40%2C%60%600%2C%60%600)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/Interlocked.cs/#L173">View Source</a>
              </span>
              <h4 id="System_Threading_Interlocked_CompareExchange__1___0____0___0_" data-uid="System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">CompareExchange&lt;T&gt;(ref T, T, T)</h4>
              <div class="markdown level1 summary"><p>Compares two instances of the specified reference type <em>T</em> for equality and, if they are equal, replaces the first one.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Interlocked_CompareExchange__1___0____0___0__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>comparand</em> and the value in <em>location1</em> are equal, then <em>value</em> is stored in <em>location1</em>. Otherwise, no operation is performed. The comparison and the exchange are performed as an atomic operation. The return value of this method is the original value in <em>location1</em>, whether or not the exchange takes place.</p>
<p>This method only supports reference types. There are overloads of the <see cref="Overload:System.Threading.Interlocked.CompareExchange"></see> method for the value types <a class="xref" href="System.Int32.html#System_Int32">Int32</a>, <a class="xref" href="System.Int64.html#System_Int64">Int64</a>, <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a>, <a class="xref" href="System.Single.html#System_Single">Single</a>, and <a class="xref" href="System.Double.html#System_Double">Double</a>, but there is no support for other value types.</p>
<p>This method overload is preferable to the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_CompareExchange_System_Object__System_Object_System_Object_">CompareExchange(ref Object, Object, Object)</a> method overload, because the latter requires the destination object to be accessed late-bound.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
[ComVisible(false)]
[SecuritySafeCritical]
public static T CompareExchange&lt;T&gt;(ref T location1, T value, T comparand)where T : class</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><span class="xref">T</span></td>
                    <td><em>location1</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><span class="xref">T</span></td>
                    <td><em>value</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><span class="xref">T</span></td>
                    <td><em>comparand</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><span class="xref">T</span></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Interlocked_CompareExchange__1___0____0___0__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>comparand</em> and the value in <em>location1</em> are equal, then <em>value</em> is stored in <em>location1</em>. Otherwise, no operation is performed. The comparison and the exchange are performed as an atomic operation. The return value of this method is the original value in <em>location1</em>, whether or not the exchange takes place.</p>
<p>This method only supports reference types. There are overloads of the <see cref="Overload:System.Threading.Interlocked.CompareExchange"></see> method for the value types <a class="xref" href="System.Int32.html#System_Int32">Int32</a>, <a class="xref" href="System.Int64.html#System_Int64">Int64</a>, <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a>, <a class="xref" href="System.Single.html#System_Single">Single</a>, and <a class="xref" href="System.Double.html#System_Double">Double</a>, but there is no support for other value types.</p>
<p>This method overload is preferable to the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_CompareExchange_System_Object__System_Object_System_Object_">CompareExchange(ref Object, Object, Object)</a> method overload, because the latter requires the destination object to be accessed late-bound.</p>
</div>
              
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.NullReferenceException.html#System_NullReferenceException">NullReferenceException</a></td>
                    <td><p>The address of <em>location1</em> is a null pointer. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked_Decrement_System_Int32__.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked.Decrement(System.Int32%40)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/Interlocked.cs/#L46">View Source</a>
              </span>
              <h4 id="System_Threading_Interlocked_Decrement_System_Int32__" data-uid="System.Threading.Interlocked.Decrement(System.Int32@)">Decrement(ref Int32)</h4>
              <div class="markdown level1 summary"><p>Decrements a specified variable and stores the result, as an atomic operation.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Interlocked_Decrement_System_Int32___remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method handles an overflow condition by wrapping: If <em>location</em> = <a class="xref" href="System.Int32.html#System_Int32_MinValue">MinValue</a>, <em>location</em> - 1 = <a class="xref" href="System.Int32.html#System_Int32_MaxValue">MaxValue</a>. No exception is thrown.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
public static int Decrement(ref int location)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td><em>location</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Interlocked_Decrement_System_Int32___remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method handles an overflow condition by wrapping: If <em>location</em> = <a class="xref" href="System.Int32.html#System_Int32_MinValue">MinValue</a>, <em>location</em> - 1 = <a class="xref" href="System.Int32.html#System_Int32_MaxValue">MaxValue</a>. No exception is thrown.</p>
</div>
              <h5 id="System_Threading_Interlocked_Decrement_System_Int32___examples">Examples</h5>
              
<p>The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value. To keep track of the number of midpoint values, a variable, <code>midpointCount</code>, is set equal to 1,000 and decremented each time the random number generator returns a midpoint value. Because three threads generate the random numbers, the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_Decrement_System_Int32__">Decrement(ref Int32)</a> method is called to ensure that multiple threads don't update <code>midpointCount</code> concurrently. Note that a lock is also used to protect the random number generator, and that a <a class="xref" href="System.Threading.CountdownEvent.html#System_Threading_CountdownEvent">CountdownEvent</a> object is used to ensure that the <code>Main</code> method doesn't finish execution before the three threads. </p>System.Threading.Interlocked.Decrement#1
              
<p>The following example is similar to the previous one, except that it uses the  instead of a thread procedure to generate 50,000 random midpoint integers. In this example, a lambda expression replaces the <code>GenerateNumbers</code> thread procedure, and the call to the <a class="xref" href="System.Threading.Tasks.Task.html#System_Threading_Tasks_Task_WaitAll_System_Threading_Tasks_Task___">WaitAll(Task[])</a> method eliminates the need for the <a class="xref" href="System.Threading.CountdownEvent.html#System_Threading_CountdownEvent">CountdownEvent</a> object.  </p>System.Threading.Interlocked.Decrement#2
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.ArgumentNullException.html#System_ArgumentNullException">ArgumentNullException</a></td>
                    <td><p>The address of <em>location</em> is a null pointer. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked_Decrement_System_Int64__.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked.Decrement(System.Int64%40)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/Interlocked.cs/#L52">View Source</a>
              </span>
              <h4 id="System_Threading_Interlocked_Decrement_System_Int64__" data-uid="System.Threading.Interlocked.Decrement(System.Int64@)">Decrement(ref Int64)</h4>
              <div class="markdown level1 summary"><p>Decrements the specified variable and stores the result, as an atomic operation.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Interlocked_Decrement_System_Int64___remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method handles an overflow condition by wrapping: if <em>location</em> = <a class="xref" href="System.Int64.html#System_Int64_MinValue">MinValue</a>, <em>location</em> - 1 = <a class="xref" href="System.Int64.html#System_Int64_MaxValue">MaxValue</a>. No exception is thrown.</p>
<p>The <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_Read_System_Int64__">Read(ref Int64)</a> method and the 64-bit overloads of the <see cref="Overload:System.Threading.Interlocked.Increment"></see>, <see cref="Overload:System.Threading.Interlocked.Decrement"></see>, and <see cref="Overload:System.Threading.Interlocked.Add"></see> methods are truly atomic only on systems where a <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked">Interlocked</a> class.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public static long Decrement(ref long location)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int64.html#System_Int64">Int64</a></td>
                    <td><em>location</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int64.html#System_Int64">Int64</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Interlocked_Decrement_System_Int64___remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method handles an overflow condition by wrapping: if <em>location</em> = <a class="xref" href="System.Int64.html#System_Int64_MinValue">MinValue</a>, <em>location</em> - 1 = <a class="xref" href="System.Int64.html#System_Int64_MaxValue">MaxValue</a>. No exception is thrown.</p>
<p>The <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_Read_System_Int64__">Read(ref Int64)</a> method and the 64-bit overloads of the <see cref="Overload:System.Threading.Interlocked.Increment"></see>, <see cref="Overload:System.Threading.Interlocked.Decrement"></see>, and <see cref="Overload:System.Threading.Interlocked.Add"></see> methods are truly atomic only on systems where a <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked">Interlocked</a> class.</p>
</div>
              <h5 id="System_Threading_Interlocked_Decrement_System_Int64___examples">Examples</h5>
              
<p>The following code example shows a thread-safe resource locking mechanism.</p>System.Threading.Interlocked.Exchange Int32 Example#1
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.ArgumentNullException.html#System_ArgumentNullException">ArgumentNullException</a></td>
                    <td><p>The address of <em>location</em> is a null pointer. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked_Exchange_System_Double__System_Double_.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked.Exchange(System.Double%40%2CSystem.Double)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              
              <h4 id="System_Threading_Interlocked_Exchange_System_Double__System_Double_" data-uid="System.Threading.Interlocked.Exchange(System.Double@,System.Double)">Exchange(ref Double, Double)</h4>
              <div class="markdown level1 summary"><p>Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[MethodImpl(MethodImplOptions.InternalCall)]
[SecuritySafeCritical]
public static double Exchange(ref double location1, double value)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Double.html#System_Double">Double</a></td>
                    <td><em>location1</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Double.html#System_Double">Double</a></td>
                    <td><em>value</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Double.html#System_Double">Double</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Interlocked_Exchange_System_Double__System_Double__examples">Examples</h5>
              
<p>The following code example shows a thread-safe resource locking mechanism.</p>System.Threading.Interlocked.Exchange Int32 Example#1
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.NullReferenceException.html#System_NullReferenceException">NullReferenceException</a></td>
                    <td><p>The address of <em>location1</em> is a null pointer. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked_Exchange_System_Int32__System_Int32_.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked.Exchange(System.Int32%40%2CSystem.Int32)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              
              <h4 id="System_Threading_Interlocked_Exchange_System_Int32__System_Int32_" data-uid="System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">Exchange(ref Int32, Int32)</h4>
              <div class="markdown level1 summary"><p>Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[MethodImpl(MethodImplOptions.InternalCall)]
[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
[SecuritySafeCritical]
public static int Exchange(ref int location1, int value)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td><em>location1</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td><em>value</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Interlocked_Exchange_System_Int32__System_Int32__examples">Examples</h5>
              
<p>The following code example shows a thread-safe resource locking mechanism.</p>System.Threading.Interlocked.Exchange Int32 Example#1
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.ArgumentNullException.html#System_ArgumentNullException">ArgumentNullException</a></td>
                    <td><p>The address of <em>location1</em> is a null pointer. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked_Exchange_System_Int64__System_Int64_.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked.Exchange(System.Int64%40%2CSystem.Int64)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              
              <h4 id="System_Threading_Interlocked_Exchange_System_Int64__System_Int64_" data-uid="System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">Exchange(ref Int64, Int64)</h4>
              <div class="markdown level1 summary"><p>Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[MethodImpl(MethodImplOptions.InternalCall)]
[SecuritySafeCritical]
public static long Exchange(ref long location1, long value)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int64.html#System_Int64">Int64</a></td>
                    <td><em>location1</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Int64.html#System_Int64">Int64</a></td>
                    <td><em>value</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int64.html#System_Int64">Int64</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.NullReferenceException.html#System_NullReferenceException">NullReferenceException</a></td>
                    <td><p>The address of <em>location1</em> is a null pointer. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked_Exchange_System_IntPtr__System_IntPtr_.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked.Exchange(System.IntPtr%40%2CSystem.IntPtr)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              
              <h4 id="System_Threading_Interlocked_Exchange_System_IntPtr__System_IntPtr_" data-uid="System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">Exchange(ref IntPtr, IntPtr)</h4>
              <div class="markdown level1 summary"><p>Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[MethodImpl(MethodImplOptions.InternalCall)]
[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
[SecuritySafeCritical]
public static IntPtr Exchange(ref IntPtr location1, IntPtr value)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a></td>
                    <td><em>location1</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a></td>
                    <td><em>value</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.NullReferenceException.html#System_NullReferenceException">NullReferenceException</a></td>
                    <td><p>The address of <em>location1</em> is a null pointer. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked_Exchange_System_Object__System_Object_.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked.Exchange(System.Object%40%2CSystem.Object)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              
              <h4 id="System_Threading_Interlocked_Exchange_System_Object__System_Object_" data-uid="System.Threading.Interlocked.Exchange(System.Object@,System.Object)">Exchange(ref Object, Object)</h4>
              <div class="markdown level1 summary"><p>Sets an object to a specified value and returns a reference to the original object, as an atomic operation.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Interlocked_Exchange_System_Object__System_Object__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Beginning with .NET Framework version 2.0, the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_Exchange__1___0____0_">Exchange<t>(ref T, T)</t></a> method overload provides a type-safe alternative for reference types.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[MethodImpl(MethodImplOptions.InternalCall)]
[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
[SecuritySafeCritical]
public static object Exchange(ref object location1, object value)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Object.html#System_Object">Object</a></td>
                    <td><em>location1</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Object.html#System_Object">Object</a></td>
                    <td><em>value</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Object.html#System_Object">Object</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Interlocked_Exchange_System_Object__System_Object__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Beginning with .NET Framework version 2.0, the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_Exchange__1___0____0_">Exchange<t>(ref T, T)</t></a> method overload provides a type-safe alternative for reference types.</p>
</div>
              <h5 id="System_Threading_Interlocked_Exchange_System_Object__System_Object__examples">Examples</h5>
              
<p>The following code example shows the syntax for using <strong>Exchange</strong> with any reference type object.</p>System.Threading.Interlocked.Exchange#1
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.ArgumentNullException.html#System_ArgumentNullException">ArgumentNullException</a></td>
                    <td><p>The address of <em>location1</em> is a null pointer. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked_Exchange_System_Single__System_Single_.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked.Exchange(System.Single%40%2CSystem.Single)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              
              <h4 id="System_Threading_Interlocked_Exchange_System_Single__System_Single_" data-uid="System.Threading.Interlocked.Exchange(System.Single@,System.Single)">Exchange(ref Single, Single)</h4>
              <div class="markdown level1 summary"><p>Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[MethodImpl(MethodImplOptions.InternalCall)]
[SecuritySafeCritical]
public static float Exchange(ref float location1, float value)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Single.html#System_Single">Single</a></td>
                    <td><em>location1</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Single.html#System_Single">Single</a></td>
                    <td><em>value</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Single.html#System_Single">Single</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Interlocked_Exchange_System_Single__System_Single__examples">Examples</h5>
              
<p>The following code example shows a thread-safe resource locking mechanism.</p>System.Threading.Interlocked.Exchange Int32 Example#1
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.NullReferenceException.html#System_NullReferenceException">NullReferenceException</a></td>
                    <td><p>The address of <em>location1</em> is a null pointer. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked_Exchange__1___0____0_.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked.Exchange%60%601(%60%600%40%2C%60%600)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/Interlocked.cs/#L94">View Source</a>
              </span>
              <h4 id="System_Threading_Interlocked_Exchange__1___0____0_" data-uid="System.Threading.Interlocked.Exchange``1(``0@,``0)">Exchange&lt;T&gt;(ref T, T)</h4>
              <div class="markdown level1 summary"><p>Sets a variable of the specified type <em>T</em> to a specified value and returns the original value, as an atomic operation.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Interlocked_Exchange__1___0____0__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method only supports reference types. There are overloads of the <see cref="Overload:System.Threading.Interlocked.Exchange"></see> method for the <a class="xref" href="System.Int32.html#System_Int32">Int32</a>, <a class="xref" href="System.Int64.html#System_Int64">Int64</a>, <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a>, <a class="xref" href="System.Single.html#System_Single">Single</a>, and <a class="xref" href="System.Double.html#System_Double">Double</a> value types, but there is no support for other value types.</p>
<p>This method overload is preferable to the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_Exchange_System_Object__System_Object_">Exchange(ref Object, Object)</a> method overload, because the latter requires late-bound access to the destination object .  </p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
[ComVisible(false)]
[SecuritySafeCritical]
public static T Exchange&lt;T&gt;(ref T location1, T value)where T : class</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><span class="xref">T</span></td>
                    <td><em>location1</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><span class="xref">T</span></td>
                    <td><em>value</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><span class="xref">T</span></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Interlocked_Exchange__1___0____0__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method only supports reference types. There are overloads of the <see cref="Overload:System.Threading.Interlocked.Exchange"></see> method for the <a class="xref" href="System.Int32.html#System_Int32">Int32</a>, <a class="xref" href="System.Int64.html#System_Int64">Int64</a>, <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a>, <a class="xref" href="System.Single.html#System_Single">Single</a>, and <a class="xref" href="System.Double.html#System_Double">Double</a> value types, but there is no support for other value types.</p>
<p>This method overload is preferable to the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_Exchange_System_Object__System_Object_">Exchange(ref Object, Object)</a> method overload, because the latter requires late-bound access to the destination object .  </p>
</div>
              <h5 id="System_Threading_Interlocked_Exchange__1___0____0__examples">Examples</h5>
              
<p>The following example launches ten tasks, each of which generates  100 ten-character part numbers. It then the part number that is first alphabetically. </p>System.Threading.Interlocked.Exchange#2<p>The example uses the <code>firstWidget</code> variable to store the ID that occurs first in the sort order. It compares each ID that it generates with the <code>firstWidget</code> value.  If the new value precedes the current value of <code>firstWidget</code> in the sort order, the example calls the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_Exchange__1___0____0_">Exchange<t>(ref T, T)</t></a> method to assign the new value to <code>firstWidget</code>. </p>
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.NullReferenceException.html#System_NullReferenceException">NullReferenceException</a></td>
                    <td><p>The address of <em>location1</em> is a null pointer. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked_Increment_System_Int32__.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked.Increment(System.Int32%40)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/Interlocked.cs/#L28">View Source</a>
              </span>
              <h4 id="System_Threading_Interlocked_Increment_System_Int32__" data-uid="System.Threading.Interlocked.Increment(System.Int32@)">Increment(ref Int32)</h4>
              <div class="markdown level1 summary"><p>Increments a specified variable and stores the result, as an atomic operation.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Interlocked_Increment_System_Int32___remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method handles an overflow condition by wrapping: if <em>location</em> = <a class="xref" href="System.Int32.html#System_Int32_MaxValue">MaxValue</a>, <em>location</em> + 1 = <a class="xref" href="System.Int32.html#System_Int32_MinValue">MinValue</a>. No exception is thrown.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
public static int Increment(ref int location)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td><em>location</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Interlocked_Increment_System_Int32___remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method handles an overflow condition by wrapping: if <em>location</em> = <a class="xref" href="System.Int32.html#System_Int32_MaxValue">MaxValue</a>, <em>location</em> + 1 = <a class="xref" href="System.Int32.html#System_Int32_MinValue">MinValue</a>. No exception is thrown.</p>
</div>
              <h5 id="System_Threading_Interlocked_Increment_System_Int32___examples">Examples</h5>
              
<p>The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value. To keep track of the number of midpoint values, a variable, <code>midpointCount</code>, is set equal to 0 and incremented each time the random number generator returns a midpoint value until it reaches 10,000. Because three threads generate the random numbers, the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_Increment_System_Int32__">Increment(ref Int32)</a> method is called to ensure that multiple threads don't update <code>midpointCount</code> concurrently. Note that a lock is also used to protect the random number generator, and that a <a class="xref" href="System.Threading.CountdownEvent.html#System_Threading_CountdownEvent">CountdownEvent</a> object is used to ensure that the <code>Main</code> method doesn't finish execution before the three threads. </p>System.Threading.Interlocked.Increment2#3
              
<p>The following example is similar to the previous one, except that it uses the  instead of a thread procedure to generate 50,000 random midpoint integers. In this example, a lambda expression replaces the <code>GenerateNumbers</code> thread procedure, and the call to the <a class="xref" href="System.Threading.Tasks.Task.html#System_Threading_Tasks_Task_WaitAll_System_Threading_Tasks_Task___">WaitAll(Task[])</a> method eliminates the need for the <a class="xref" href="System.Threading.CountdownEvent.html#System_Threading_CountdownEvent">CountdownEvent</a> object. </p>System.Threading.Interlocked.Increment2#4
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.NullReferenceException.html#System_NullReferenceException">NullReferenceException</a></td>
                    <td><p>The address of <em>location</em> is a null pointer. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked_Increment_System_Int64__.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked.Increment(System.Int64%40)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/Interlocked.cs/#L34">View Source</a>
              </span>
              <h4 id="System_Threading_Interlocked_Increment_System_Int64__" data-uid="System.Threading.Interlocked.Increment(System.Int64@)">Increment(ref Int64)</h4>
              <div class="markdown level1 summary"><p>Increments a specified variable and stores the result, as an atomic operation.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Interlocked_Increment_System_Int64___remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method handles an overflow condition by wrapping: if <em>location</em> = <a class="xref" href="System.Int64.html#System_Int64_MaxValue">MaxValue</a>, <em>location</em> + 1 = <a class="xref" href="System.Int64.html#System_Int64_MinValue">MinValue</a>. No exception is thrown.</p>
<p>The <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_Read_System_Int64__">Read(ref Int64)</a> method and the 64-bit overloads of the <see cref="Overload:System.Threading.Interlocked.Increment"></see>, <see cref="Overload:System.Threading.Interlocked.Decrement"></see>, and <see cref="Overload:System.Threading.Interlocked.Add"></see> methods are truly atomic only on systems where a <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked">Interlocked</a> class.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
public static long Increment(ref long location)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int64.html#System_Int64">Int64</a></td>
                    <td><em>location</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int64.html#System_Int64">Int64</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Interlocked_Increment_System_Int64___remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method handles an overflow condition by wrapping: if <em>location</em> = <a class="xref" href="System.Int64.html#System_Int64_MaxValue">MaxValue</a>, <em>location</em> + 1 = <a class="xref" href="System.Int64.html#System_Int64_MinValue">MinValue</a>. No exception is thrown.</p>
<p>The <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_Read_System_Int64__">Read(ref Int64)</a> method and the 64-bit overloads of the <see cref="Overload:System.Threading.Interlocked.Increment"></see>, <see cref="Overload:System.Threading.Interlocked.Decrement"></see>, and <see cref="Overload:System.Threading.Interlocked.Add"></see> methods are truly atomic only on systems where a <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked">Interlocked</a> class.</p>
</div>
              <h5 id="System_Threading_Interlocked_Increment_System_Int64___examples">Examples</h5>
              
<p>The following code example shows a thread-safe resource locking mechanism.</p>System.Threading.Interlocked.Exchange Int32 Example#1
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.NullReferenceException.html#System_NullReferenceException">NullReferenceException</a></td>
                    <td><p>The address of <em>location</em> is a null pointer. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked_MemoryBarrier.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked.MemoryBarrier%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/Interlocked.cs/#L228">View Source</a>
              </span>
              <h4 id="System_Threading_Interlocked_MemoryBarrier" data-uid="System.Threading.Interlocked.MemoryBarrier">MemoryBarrier()</h4>
              <div class="markdown level1 summary"><p>Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_MemoryBarrier">MemoryBarrier()</a> execute after memory accesses that follow the call to <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_MemoryBarrier">MemoryBarrier()</a>.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Interlocked_MemoryBarrier_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method was added to the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked">Interlocked</a> class in the .NET Framework 4.5 as a convenience; it&#39;s a wrapper for the <span class="xref">System.Threading.Thread.MemoryBarrier</span> method. </p>
<p>
<a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_MemoryBarrier">MemoryBarrier()</a> is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors).</p>
<p>For most purposes, the C# <strong>lock</strong> statement, the Visual Basic <strong>SyncLock</strong> statement, or the <a class="xref" href="System.Threading.Monitor.html#System_Threading_Monitor">Monitor</a> class provide easier ways to synchronize data.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public static void MemoryBarrier()</code></pre>
              </div>
              <h5 id="System_Threading_Interlocked_MemoryBarrier_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method was added to the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked">Interlocked</a> class in the .NET Framework 4.5 as a convenience; it&#39;s a wrapper for the <span class="xref">System.Threading.Thread.MemoryBarrier</span> method. </p>
<p>
<a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_MemoryBarrier">MemoryBarrier()</a> is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors).</p>
<p>For most purposes, the C# <strong>lock</strong> statement, the Visual Basic <strong>SyncLock</strong> statement, or the <a class="xref" href="System.Threading.Monitor.html#System_Threading_Monitor">Monitor</a> class provide easier ways to synchronize data.</p>
</div>
              <h5 id="System_Threading_Interlocked_MemoryBarrier_examples">Examples</h5>
              
<p>The following code example shows a thread-safe resource locking mechanism.</p>System.Threading.Interlocked.Exchange Int32 Example#1
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Interlocked_Read_System_Int64__.md&amp;value=---%0Auid%3A%20System.Threading.Interlocked.Read(System.Int64%40)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/Interlocked.cs/#L222">View Source</a>
              </span>
              <h4 id="System_Threading_Interlocked_Read_System_Int64__" data-uid="System.Threading.Interlocked.Read(System.Int64@)">Read(ref Int64)</h4>
              <div class="markdown level1 summary"><p>Returns a 64-bit value, loaded as an atomic operation.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Interlocked_Read_System_Int64___remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>The <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_Read_System_Int64__">Read(ref Int64)</a> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic. On 32-bit systems, 64-bit read operations are not atomic unless performed using <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_Read_System_Int64__">Read(ref Int64)</a>.</p>
<p>The <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_Read_System_Int64__">Read(ref Int64)</a> method and the 64-bit overloads of the <see cref="Overload:System.Threading.Interlocked.Increment"></see>, <see cref="Overload:System.Threading.Interlocked.Decrement"></see>, and <see cref="Overload:System.Threading.Interlocked.Add"></see> methods are truly atomic only on systems where a <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked">Interlocked</a> class.</p>
<p>
<a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> is a platform-specific type.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public static long Read(ref long location)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int64.html#System_Int64">Int64</a></td>
                    <td><em>location</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int64.html#System_Int64">Int64</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Interlocked_Read_System_Int64___remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>The <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_Read_System_Int64__">Read(ref Int64)</a> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic. On 32-bit systems, 64-bit read operations are not atomic unless performed using <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_Read_System_Int64__">Read(ref Int64)</a>.</p>
<p>The <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked_Read_System_Int64__">Read(ref Int64)</a> method and the 64-bit overloads of the <see cref="Overload:System.Threading.Interlocked.Increment"></see>, <see cref="Overload:System.Threading.Interlocked.Decrement"></see>, and <see cref="Overload:System.Threading.Interlocked.Add"></see> methods are truly atomic only on systems where a <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <a class="xref" href="System.Threading.Interlocked.html#System_Threading_Interlocked">Interlocked</a> class.</p>
<p>
<a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> is a platform-specific type.</p>
</div>
              
            </article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
            <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
            </nav>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="inner-footer">
          <p>© .NET Foundation</p>
          <p>
            <a href="https://www.github.com/dotnet" target="_blank"><span class="fa fa-stack fa-lg">
              <span class="fa fa-square-o fa-stack-2x"></span>
              <span class="fa fa-github fa-stack-1x"></span>
            </span></a>
            <a href="https://twitter.com/dotnet" target="_blank"><span class="fa fa-stack fa-lg">
              <span class="fa fa-square-o fa-stack-2x"></span>
              <span class="fa fa-twitter fa-stack-1x"></span>
            </span></a>
            <a href="https://www.facebook.com/dotnet" target="_blank"><span class="fa fa-stack fa-lg">
              <span class="fa fa-square-o fa-stack-2x"></span>
              <span class="fa fa-facebook fa-stack-1x"></span>
            </span></a>
      
          </p>
          </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
