<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Class ReaderWriterLockSlim
   | CoreCLR site </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Class ReaderWriterLockSlim
   | CoreCLR site ">
    
    <link rel="shortcut icon" href="../images/Logo_DotNet.png" type="image/x-icon">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/main.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/style.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  
    ga('create', 'UA-63735192-1', 'auto');
    ga('send', 'pageview');
    </script>
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav class="navbar navbar-inverse">
             <div class="container">
               <a href="../"><img height="50px" src="../images/Logo_DotNet.png" style="float:right;"></a>
               <div class="navbar-header ">
                 <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                   <span class="sr-only">Toggle navigation</span>
                   <span class="icon-bar"></span>
                   <span class="icon-bar"></span>
                   <span class="icon-bar"></span>
                 </button>
                 <a class="navbar-brand" href="../"><span class="dotnet">.NET Core</span></a>
               </div>
               <div id="navbar" class="collapse navbar-collapse">
               </div><!--/.nav-collapse -->
             </div>
           </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content">
              
              <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A" class="pull-right mobile-hide"><span class="fa fa-github"></span>Improve this Doc</a>
              <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L216" class="pull-right mobile-hide">View Source</a>
              <h1 id="System_Threading_ReaderWriterLockSlim" data-uid="System.Threading.ReaderWriterLockSlim">Class ReaderWriterLockSlim
              </h1>
              <div class="markdown level0 summary"><p>Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</p>
</div>
              <div class="markdown level0 conceptual"></div>
              <div class="inheritance">
                <h5>Inheritance</h5>
                  <div class="level0"><a class="xref" href="System.Object.html#System_Object">Object</a></div>
                  <div class="level1"><span class="xref">ReaderWriterLockSlim</span></div>
              </div>
              <div class="inheritedMembers">
                <h5>Inherited Members</h5>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_ToString">ToString()</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_Equals_System_Object_">Equals(Object)</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_Equals_System_Object_System_Object_">Equals(Object, Object)</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_ReferenceEquals_System_Object_System_Object_">ReferenceEquals(Object, Object)</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_GetHashCode">GetHashCode()</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_GetType">GetType()</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_MemberwiseClone">MemberwiseClone()</a>
                </div>
              </div>
              <h6><strong>Namespace</strong>:System.Threading</h6>
              <h6><strong>Assembly</strong>:System.Threading.dll</h6>
              <h5 id="System_Threading_ReaderWriterLockSlim_syntax">Syntax</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public class ReaderWriterLockSlim : IDisposable</code></pre>
              </div>
              <h5 id="System_Threading_ReaderWriterLockSlim_examples"><strong>Examples</strong></h5>
              <p>The following example shows a simple synchronized cache that holds strings with integer keys. An instance of <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is used to synchronize access to the <a class="xref" href="System.Collections.Generic.Dictionary%602.html#System_Collections_Generic_Dictionary_2">Dictionary<tkey, tvalue=""></tkey,></a> that serves as the inner cache. </p>
<p>The example includes simple methods to add to the cache, delete from the cache, and read from the cache. To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out. </p>
<p>To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value. If the value is unchanged, the method returns a status indicating no change. It no value is found for the key, the key/value pair is inserted. If the value has changed, it is updated. Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</p>
<p>The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode. </p>
<p>The example uses the default constructor to create the lock, so recursion is not allowed. Programming the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is simpler and less prone to error when the lock does not allow recursion. </p>System.Threading.ReaderWriterLockSlim_Shadow#11,12<p>The following code then uses the <code>SynchronizedCache</code> object to store a dictionary of vegetable names. It creates three tasks. The first writes the names of vegetables stored in an array to a <code>SynchronizedCache</code> instance. The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order. The final task searches for the string "cucumber" and, when it finds it, calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterUpgradeableReadLock">EnterUpgradeableReadLock()</a> method  to substitute the string "green bean". </p>System.Threading.ReaderWriterLockSlim_Shadow#11,13
              <h3 id="constructors">Constructors
              </h3>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim__ctor.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.%23ctor%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L218">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim__ctor" data-uid="System.Threading.ReaderWriterLockSlim.#ctor">ReaderWriterLockSlim()</h4>
              <div class="markdown level1 summary"><p>Initializes a new instance of the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> class with default property values.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim__ctor_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>A <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> that is initialized with this constructor does not allow recursion. That is, the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_RecursionPolicy">RecursionPolicy</a> property returns <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy_NoRecursion">NoRecursion</a>. </p>
<p>For more information about recursion policy and its effects, see the <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy">LockRecursionPolicy</a> enumeration and the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> class.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public ReaderWriterLockSlim()</code></pre>
              </div>
              <h5 id="System_Threading_ReaderWriterLockSlim__ctor_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>A <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> that is initialized with this constructor does not allow recursion. That is, the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_RecursionPolicy">RecursionPolicy</a> property returns <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy_NoRecursion">NoRecursion</a>. </p>
<p>For more information about recursion policy and its effects, see the <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy">LockRecursionPolicy</a> enumeration and the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> class.</p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim__ctor_examples">Examples</h5>
              
<p>The following example shows a simple synchronized cache that holds strings with integer keys. An instance of <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is used to synchronize access to the <a class="xref" href="System.Collections.Generic.Dictionary%602.html#System_Collections_Generic_Dictionary_2">Dictionary<tkey, tvalue=""></tkey,></a> that serves as the inner cache. The parameterless constructor is used to create the lock.</p>
<p>The example includes simple methods to add to the cache, delete from the cache, and read from the cache. To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out. </p>
<p>To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value. If the value is unchanged, the method returns a status indicating no change. It no value is found for the key, the key/value pair is inserted. If the value has changed, it is updated. Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</p>
<p>The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode. </p>
<p>The example uses the default constructor to create the lock, so recursion is not allowed. Programming the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is simpler and less prone to error when the lock does not allow recursion. </p>System.Threading.ReaderWriterLockSlim_Shadow#11,12<p>The following code then uses the <code>SynchronizedCache</code> object to store a dictionary of vegetable names. It creates three tasks. The first writes the names of vegetables stored in an array to a <code>SynchronizedCache</code> instance. The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order. The final task searches for the string "cucumber" and, when it finds it, calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterUpgradeableReadLock">EnterUpgradeableReadLock()</a> method  to substitute the string "green bean". </p>System.Threading.ReaderWriterLockSlim_Shadow#11,13
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim__ctor_System_Threading_LockRecursionPolicy_.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.%23ctor(System.Threading.LockRecursionPolicy)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L219">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim__ctor_System_Threading_LockRecursionPolicy_" data-uid="System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">ReaderWriterLockSlim(LockRecursionPolicy)</h4>
              <div class="markdown level1 summary"><p>Initializes a new instance of the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> class, specifying the lock recursion policy.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim__ctor_System_Threading_LockRecursionPolicy__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Recursion policy determines the restrictions on threads that enter the lock more than once. For example, if a lock was created with <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy_NoRecursion">NoRecursion</a> and a thread has entered the lock in read mode, <a class="xref" href="System.Threading.LockRecursionException.html#System_Threading_LockRecursionException">LockRecursionException</a> is thrown if the thread tries to reenter the lock in read mode. Similarly, if a thread has entered the lock in write mode, <a class="xref" href="System.Threading.LockRecursionException.html#System_Threading_LockRecursionException">LockRecursionException</a> is thrown if the thread tries to reenter the lock in any mode. </p>
<p>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting. </p>
<p>Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks. </p>
<p>For more information about recursion policy and its effects, see the <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy">LockRecursionPolicy</a> enumeration and the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> class.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public ReaderWriterLockSlim(LockRecursionPolicy recursionPolicy)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy">LockRecursionPolicy</a></td>
                    <td><em>recursionPolicy</em></td>
                    <td><p>One of the enumeration values that specifies the lock recursion policy.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ReaderWriterLockSlim__ctor_System_Threading_LockRecursionPolicy__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Recursion policy determines the restrictions on threads that enter the lock more than once. For example, if a lock was created with <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy_NoRecursion">NoRecursion</a> and a thread has entered the lock in read mode, <a class="xref" href="System.Threading.LockRecursionException.html#System_Threading_LockRecursionException">LockRecursionException</a> is thrown if the thread tries to reenter the lock in read mode. Similarly, if a thread has entered the lock in write mode, <a class="xref" href="System.Threading.LockRecursionException.html#System_Threading_LockRecursionException">LockRecursionException</a> is thrown if the thread tries to reenter the lock in any mode. </p>
<p>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting. </p>
<p>Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks. </p>
<p>For more information about recursion policy and its effects, see the <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy">LockRecursionPolicy</a> enumeration and the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> class.</p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim__ctor_System_Threading_LockRecursionPolicy__examples">Examples</h5>
              
<p>The following example shows two exception scenarios, one that depends on the <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy">LockRecursionPolicy</a> setting and one that does not. </p>
<p>In the first scenario, the thread enters read mode and then tries to enter read mode recursively. If the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is created by using the default constructor, which sets recursion policy to <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy_NoRecursion">NoRecursion</a>, an exception is thrown. If <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy_SupportsRecursion">SupportsRecursion</a> is used to create the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a>, no exception is thrown.</p>
<p>In the second scenario, the thread enters read mode and then tries to enter write mode. <a class="xref" href="System.Threading.LockRecursionException.html#System_Threading_LockRecursionException">LockRecursionException</a> is thrown regardless of the lock recursion policy.</p>System.Threading.LockRecursionPolicy#11,12<p>The following code then uses the <code>SynchronizedCache</code> object to store a dictionary of vegetable names. It creates three tasks. The first writes the names of vegetables stored in an array to a <code>SynchronizedCache</code> instance. The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order. The final task searches for the string "cucumber" and, when it finds it, calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterUpgradeableReadLock">EnterUpgradeableReadLock()</a> method  to substitute the string "green bean". </p>System.Threading.LockRecursionPolicy#11,13
              <h3 id="properties">Properties
              </h3>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_CurrentReadCount.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.CurrentReadCount%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L220">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_CurrentReadCount" data-uid="System.Threading.ReaderWriterLockSlim.CurrentReadCount">CurrentReadCount</h4>
              <div class="markdown level1 summary"><p>Gets the total number of unique threads that have entered the lock in read mode.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_CurrentReadCount_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.</p>
<p>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public int CurrentReadCount { get; }</code></pre>
              </div>
              <h5 class="propertyValue"></h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td><p>The number of unique threads that have entered the lock in read mode.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ReaderWriterLockSlim_CurrentReadCount_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.</p>
<p>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.</p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_CurrentReadCount_examples">Examples</h5>
              
<p>The following example shows how to use the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_CurrentReadCount">CurrentReadCount</a> property to generate an event log entry if the number of threads in read mode exceeds a threshold.</p>System.Threading.ReaderWriterLockSlim_Aux#1,2,11
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_IsReadLockHeld.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.IsReadLockHeld%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L221">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_IsReadLockHeld" data-uid="System.Threading.ReaderWriterLockSlim.IsReadLockHeld">IsReadLockHeld</h4>
              <div class="markdown level1 summary"><p>Gets a value that indicates whether the current thread has entered the lock in read mode.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_IsReadLockHeld_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This property is intended for use in asserts or for other debugging purposes. Do not use it to control the flow of program execution.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public bool IsReadLockHeld { get; }</code></pre>
              </div>
              <h5 class="propertyValue"></h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td><p>
<strong>true</strong> if the current thread has entered read mode; otherwise, <strong>false</strong>.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ReaderWriterLockSlim_IsReadLockHeld_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This property is intended for use in asserts or for other debugging purposes. Do not use it to control the flow of program execution.</p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_IsReadLockHeld_examples">Examples</h5>
              
<p>The following example shows how to use the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_IsReadLockHeld">IsReadLockHeld</a> property to generate an assert if the current thread has entered read mode unexpectedly.</p>System.Threading.ReaderWriterLockSlim_Aux#1,21
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_IsUpgradeableReadLockHeld.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L222">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_IsUpgradeableReadLockHeld" data-uid="System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">IsUpgradeableReadLockHeld</h4>
              <div class="markdown level1 summary"><p>Gets a value that indicates whether the current thread has entered the lock in upgradeable mode. </p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_IsUpgradeableReadLockHeld_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This property is intended for use in asserts or for other debugging purposes. Do not use it to control the flow of program execution.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public bool IsUpgradeableReadLockHeld { get; }</code></pre>
              </div>
              <h5 class="propertyValue"></h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td><p>
<strong>true</strong> if the current thread has entered upgradeable mode; otherwise, <strong>false</strong>.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ReaderWriterLockSlim_IsUpgradeableReadLockHeld_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This property is intended for use in asserts or for other debugging purposes. Do not use it to control the flow of program execution.</p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_IsUpgradeableReadLockHeld_examples">Examples</h5>
              
<p>The following example shows how to use the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_IsUpgradeableReadLockHeld">IsUpgradeableReadLockHeld</a> property to generate an assert if the current thread has entered upgradeable mode unexpectedly.</p>System.Threading.ReaderWriterLockSlim_Aux#1,22
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_IsWriteLockHeld.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L223">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_IsWriteLockHeld" data-uid="System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">IsWriteLockHeld</h4>
              <div class="markdown level1 summary"><p>Gets a value that indicates whether the current thread has entered the lock in write mode.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_IsWriteLockHeld_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This property is intended for use in asserts or for other debugging purposes. Do not use it to control the flow of program execution.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public bool IsWriteLockHeld { get; }</code></pre>
              </div>
              <h5 class="propertyValue"></h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td><p>
<strong>true</strong> if the current thread has entered write mode; otherwise, <strong>false</strong>.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ReaderWriterLockSlim_IsWriteLockHeld_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This property is intended for use in asserts or for other debugging purposes. Do not use it to control the flow of program execution.</p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_IsWriteLockHeld_examples">Examples</h5>
              
<p>The following example shows how to use the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_IsWriteLockHeld">IsWriteLockHeld</a> property to generate an assert if the current thread has entered write mode unexpectedly.</p>System.Threading.ReaderWriterLockSlim_Aux#1,23
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_RecursionPolicy.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.RecursionPolicy%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L224">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_RecursionPolicy" data-uid="System.Threading.ReaderWriterLockSlim.RecursionPolicy">RecursionPolicy</h4>
              <div class="markdown level1 summary"><p>Gets a value that indicates the recursion policy for the current <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> object.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_RecursionPolicy_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Recursion policy determines the restrictions on threads that enter the lock more than once. For example, if a lock was created with <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy_NoRecursion">NoRecursion</a> and a thread has entered the lock in read mode, <a class="xref" href="System.Threading.LockRecursionException.html#System_Threading_LockRecursionException">LockRecursionException</a> is thrown if the thread tries to reenter the lock in read mode. </p>
<p>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting. </p>
<p>Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks. </p>
<p>For more information about recursion policy and its effects, see the <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy">LockRecursionPolicy</a> enumeration and the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> class.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public LockRecursionPolicy RecursionPolicy { get; }</code></pre>
              </div>
              <h5 class="propertyValue"></h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy">LockRecursionPolicy</a></td>
                    <td><p>One of the enumeration values that specifies the lock recursion policy.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ReaderWriterLockSlim_RecursionPolicy_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Recursion policy determines the restrictions on threads that enter the lock more than once. For example, if a lock was created with <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy_NoRecursion">NoRecursion</a> and a thread has entered the lock in read mode, <a class="xref" href="System.Threading.LockRecursionException.html#System_Threading_LockRecursionException">LockRecursionException</a> is thrown if the thread tries to reenter the lock in read mode. </p>
<p>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting. </p>
<p>Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks. </p>
<p>For more information about recursion policy and its effects, see the <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy">LockRecursionPolicy</a> enumeration and the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> class.</p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_RecursionPolicy_examples">Examples</h5>
              <p>The following example shows a simple synchronized cache that holds strings with integer keys. An instance of <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is used to synchronize access to the <a class="xref" href="System.Collections.Generic.Dictionary%602.html#System_Collections_Generic_Dictionary_2">Dictionary<tkey, tvalue=""></tkey,></a> that serves as the inner cache. </p>
<p>The example includes simple methods to add to the cache, delete from the cache, and read from the cache. To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out. </p>
<p>To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value. If the value is unchanged, the method returns a status indicating no change. It no value is found for the key, the key/value pair is inserted. If the value has changed, it is updated. Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</p>
<p>The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode. </p>
<p>The example uses the default constructor to create the lock, so recursion is not allowed. Programming the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is simpler and less prone to error when the lock does not allow recursion. </p>System.Threading.ReaderWriterLockSlim_Shadow#11,12<p>The following code then uses the <code>SynchronizedCache</code> object to store a dictionary of vegetable names. It creates three tasks. The first writes the names of vegetables stored in an array to a <code>SynchronizedCache</code> instance. The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order. The final task searches for the string "cucumber" and, when it finds it, calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterUpgradeableReadLock">EnterUpgradeableReadLock()</a> method  to substitute the string "green bean". </p>System.Threading.ReaderWriterLockSlim_Shadow#11,13
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_RecursiveReadCount.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.RecursiveReadCount%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L225">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_RecursiveReadCount" data-uid="System.Threading.ReaderWriterLockSlim.RecursiveReadCount">RecursiveReadCount</h4>
              <div class="markdown level1 summary"><p>Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_RecursiveReadCount_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public int RecursiveReadCount { get; }</code></pre>
              </div>
              <h5 class="propertyValue"></h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td><p>0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or n if the thread has entered the lock recursively n - 1 times.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ReaderWriterLockSlim_RecursiveReadCount_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.</p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_RecursiveReadCount_examples">Examples</h5>
              <p>The following example shows a simple synchronized cache that holds strings with integer keys. An instance of <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is used to synchronize access to the <a class="xref" href="System.Collections.Generic.Dictionary%602.html#System_Collections_Generic_Dictionary_2">Dictionary<tkey, tvalue=""></tkey,></a> that serves as the inner cache. </p>
<p>The example includes simple methods to add to the cache, delete from the cache, and read from the cache. To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out. </p>
<p>To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value. If the value is unchanged, the method returns a status indicating no change. It no value is found for the key, the key/value pair is inserted. If the value has changed, it is updated. Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</p>
<p>The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode. </p>
<p>The example uses the default constructor to create the lock, so recursion is not allowed. Programming the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is simpler and less prone to error when the lock does not allow recursion. </p>System.Threading.ReaderWriterLockSlim_Shadow#11,12<p>The following code then uses the <code>SynchronizedCache</code> object to store a dictionary of vegetable names. It creates three tasks. The first writes the names of vegetables stored in an array to a <code>SynchronizedCache</code> instance. The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order. The final task searches for the string "cucumber" and, when it finds it, calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterUpgradeableReadLock">EnterUpgradeableReadLock()</a> method  to substitute the string "green bean". </p>System.Threading.ReaderWriterLockSlim_Shadow#11,13
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_RecursiveUpgradeCount.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L226">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_RecursiveUpgradeCount" data-uid="System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">RecursiveUpgradeCount</h4>
              <div class="markdown level1 summary"><p>Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_RecursiveUpgradeCount_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public int RecursiveUpgradeCount { get; }</code></pre>
              </div>
              <h5 class="propertyValue"></h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td><p>0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or n if the thread has entered upgradeable mode recursively n - 1 times.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ReaderWriterLockSlim_RecursiveUpgradeCount_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.</p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_RecursiveUpgradeCount_examples">Examples</h5>
              <p>The following example shows a simple synchronized cache that holds strings with integer keys. An instance of <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is used to synchronize access to the <a class="xref" href="System.Collections.Generic.Dictionary%602.html#System_Collections_Generic_Dictionary_2">Dictionary<tkey, tvalue=""></tkey,></a> that serves as the inner cache. </p>
<p>The example includes simple methods to add to the cache, delete from the cache, and read from the cache. To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out. </p>
<p>To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value. If the value is unchanged, the method returns a status indicating no change. It no value is found for the key, the key/value pair is inserted. If the value has changed, it is updated. Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</p>
<p>The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode. </p>
<p>The example uses the default constructor to create the lock, so recursion is not allowed. Programming the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is simpler and less prone to error when the lock does not allow recursion. </p>System.Threading.ReaderWriterLockSlim_Shadow#11,12<p>The following code then uses the <code>SynchronizedCache</code> object to store a dictionary of vegetable names. It creates three tasks. The first writes the names of vegetables stored in an array to a <code>SynchronizedCache</code> instance. The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order. The final task searches for the string "cucumber" and, when it finds it, calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterUpgradeableReadLock">EnterUpgradeableReadLock()</a> method  to substitute the string "green bean". </p>System.Threading.ReaderWriterLockSlim_Shadow#11,13
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_RecursiveWriteCount.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.RecursiveWriteCount%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L227">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_RecursiveWriteCount" data-uid="System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">RecursiveWriteCount</h4>
              <div class="markdown level1 summary"><p>Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_RecursiveWriteCount_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public int RecursiveWriteCount { get; }</code></pre>
              </div>
              <h5 class="propertyValue"></h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td><p>0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or n if the thread has entered write mode recursively n - 1 times.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ReaderWriterLockSlim_RecursiveWriteCount_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.</p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_RecursiveWriteCount_examples">Examples</h5>
              <p>The following example shows a simple synchronized cache that holds strings with integer keys. An instance of <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is used to synchronize access to the <a class="xref" href="System.Collections.Generic.Dictionary%602.html#System_Collections_Generic_Dictionary_2">Dictionary<tkey, tvalue=""></tkey,></a> that serves as the inner cache. </p>
<p>The example includes simple methods to add to the cache, delete from the cache, and read from the cache. To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out. </p>
<p>To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value. If the value is unchanged, the method returns a status indicating no change. It no value is found for the key, the key/value pair is inserted. If the value has changed, it is updated. Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</p>
<p>The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode. </p>
<p>The example uses the default constructor to create the lock, so recursion is not allowed. Programming the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is simpler and less prone to error when the lock does not allow recursion. </p>System.Threading.ReaderWriterLockSlim_Shadow#11,12<p>The following code then uses the <code>SynchronizedCache</code> object to store a dictionary of vegetable names. It creates three tasks. The first writes the names of vegetables stored in an array to a <code>SynchronizedCache</code> instance. The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order. The final task searches for the string "cucumber" and, when it finds it, calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterUpgradeableReadLock">EnterUpgradeableReadLock()</a> method  to substitute the string "green bean". </p>System.Threading.ReaderWriterLockSlim_Shadow#11,13
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_WaitingReadCount.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.WaitingReadCount%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L228">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_WaitingReadCount" data-uid="System.Threading.ReaderWriterLockSlim.WaitingReadCount">WaitingReadCount</h4>
              <div class="markdown level1 summary"><p>Gets the total number of threads that are waiting to enter the lock in read mode.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_WaitingReadCount_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public int WaitingReadCount { get; }</code></pre>
              </div>
              <h5 class="propertyValue"></h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td><p>The total number of threads that are waiting to enter read mode.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ReaderWriterLockSlim_WaitingReadCount_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.</p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_WaitingReadCount_examples">Examples</h5>
              
<p>The following example shows how to use the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_WaitingReadCount">WaitingReadCount</a> property to generate an event log entry if the number of threads that are blocked, waiting to enter read mode, exceeds a threshold.</p>System.Threading.ReaderWriterLockSlim_Aux#1,31
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_WaitingUpgradeCount.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L229">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_WaitingUpgradeCount" data-uid="System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">WaitingUpgradeCount</h4>
              <div class="markdown level1 summary"><p>Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_WaitingUpgradeCount_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public int WaitingUpgradeCount { get; }</code></pre>
              </div>
              <h5 class="propertyValue"></h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td><p>The total number of threads that are waiting to enter upgradeable mode.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ReaderWriterLockSlim_WaitingUpgradeCount_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.</p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_WaitingUpgradeCount_examples">Examples</h5>
              
<p>The following example shows how to use the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_WaitingUpgradeCount">WaitingUpgradeCount</a> property to generate an event log entry if the number of threads that are blocked, waiting to enter upgradeable mode, exceeds a threshold.</p>System.Threading.ReaderWriterLockSlim_Aux#1,33
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_WaitingWriteCount.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.WaitingWriteCount%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L230">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_WaitingWriteCount" data-uid="System.Threading.ReaderWriterLockSlim.WaitingWriteCount">WaitingWriteCount</h4>
              <div class="markdown level1 summary"><p>Gets the total number of threads that are waiting to enter the lock in write mode.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_WaitingWriteCount_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public int WaitingWriteCount { get; }</code></pre>
              </div>
              <h5 class="propertyValue"></h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td><p>The total number of threads that are waiting to enter write mode.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ReaderWriterLockSlim_WaitingWriteCount_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.</p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_WaitingWriteCount_examples">Examples</h5>
              
<p>The following example shows how to use the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_WaitingWriteCount">WaitingWriteCount</a> property to generate an event log entry if the number of threads that are blocked, waiting to enter write mode, exceeds a threshold.</p>System.Threading.ReaderWriterLockSlim_Aux#1,32
              <h3 id="methods">Methods
              </h3>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_Dispose.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.Dispose%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L231">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_Dispose" data-uid="System.Threading.ReaderWriterLockSlim.Dispose">Dispose()</h4>
              <div class="markdown level1 summary"><p>Releases all resources used by the current instance of the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> class.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_Dispose_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Call <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_Dispose">Dispose()</a> when you are finished using the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a>. The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_Dispose">Dispose()</a> method leaves the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> in an unusable state. After calling <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_Dispose">Dispose()</a>, you must release all references to the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> so the garbage collector can reclaim the memory that the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> was occupying. For more information, see Cleaning Up Unmanaged Resources and Implementing a Dispose Method.</p>
<p>Always call <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_Dispose">Dispose()</a> before you release your last reference to the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> object.  </p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public void Dispose()</code></pre>
              </div>
              <h5 class="implements">Implements</h5>
                  <div><a class="xref" href="System.IDisposable.html#System_IDisposable_Dispose">Dispose()</a></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_Dispose_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Call <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_Dispose">Dispose()</a> when you are finished using the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a>. The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_Dispose">Dispose()</a> method leaves the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> in an unusable state. After calling <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_Dispose">Dispose()</a>, you must release all references to the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> so the garbage collector can reclaim the memory that the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> was occupying. For more information, see Cleaning Up Unmanaged Resources and Implementing a Dispose Method.</p>
<p>Always call <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_Dispose">Dispose()</a> before you release your last reference to the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> object.  </p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_Dispose_examples">Examples</h5>
              <p>The following example shows a simple synchronized cache that holds strings with integer keys. An instance of <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is used to synchronize access to the <a class="xref" href="System.Collections.Generic.Dictionary%602.html#System_Collections_Generic_Dictionary_2">Dictionary<tkey, tvalue=""></tkey,></a> that serves as the inner cache. </p>
<p>The example includes simple methods to add to the cache, delete from the cache, and read from the cache. To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out. </p>
<p>To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value. If the value is unchanged, the method returns a status indicating no change. It no value is found for the key, the key/value pair is inserted. If the value has changed, it is updated. Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</p>
<p>The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode. </p>
<p>The example uses the default constructor to create the lock, so recursion is not allowed. Programming the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is simpler and less prone to error when the lock does not allow recursion. </p>System.Threading.ReaderWriterLockSlim_Shadow#11,12<p>The following code then uses the <code>SynchronizedCache</code> object to store a dictionary of vegetable names. It creates three tasks. The first writes the names of vegetables stored in an array to a <code>SynchronizedCache</code> instance. The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order. The final task searches for the string "cucumber" and, when it finds it, calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterUpgradeableReadLock">EnterUpgradeableReadLock()</a> method  to substitute the string "green bean". </p>System.Threading.ReaderWriterLockSlim_Shadow#11,13
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.SynchronizationLockException.html#System_Threading_SynchronizationLockException">SynchronizationLockException</a></td>
                    <td><p>
<a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_WaitingReadCount">WaitingReadCount</a> is greater than zero. </p>
<p>-or-</p>
<p>
<a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_WaitingUpgradeCount">WaitingUpgradeCount</a> is greater than zero. </p>
<p>-or-</p>
<p>
<a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_WaitingWriteCount">WaitingWriteCount</a> is greater than zero. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_EnterReadLock.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.EnterReadLock%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L232">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_EnterReadLock" data-uid="System.Threading.ReaderWriterLockSlim.EnterReadLock">EnterReadLock()</h4>
              <div class="markdown level1 summary"><p>Tries to enter the lock in read mode.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_EnterReadLock_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method blocks until the calling thread enters the lock, and therefore might never return. Use the <see cref="Overload:System.Threading.ReaderWriterLockSlim.TryEnterReadLock"></see> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval. </p>
<p>Multiple threads can enter read mode at the same time.</p>
<p>If one or more threads are waiting to enter write mode, a thread that calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterReadLock">EnterReadLock()</a> method blocks until those threads have either timed out or entered write mode and then exited from it.</p>
<p>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode. </p>
<p>At most one thread can be in upgradeable mode while other threads are in read mode. If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterReadLock">EnterReadLock()</a> method enter read mode immediately and do not block.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public void EnterReadLock()</code></pre>
              </div>
              <h5 id="System_Threading_ReaderWriterLockSlim_EnterReadLock_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method blocks until the calling thread enters the lock, and therefore might never return. Use the <see cref="Overload:System.Threading.ReaderWriterLockSlim.TryEnterReadLock"></see> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval. </p>
<p>Multiple threads can enter read mode at the same time.</p>
<p>If one or more threads are waiting to enter write mode, a thread that calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterReadLock">EnterReadLock()</a> method blocks until those threads have either timed out or entered write mode and then exited from it.</p>
<p>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode. </p>
<p>At most one thread can be in upgradeable mode while other threads are in read mode. If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterReadLock">EnterReadLock()</a> method enter read mode immediately and do not block.</p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_EnterReadLock_examples">Examples</h5>
              
<p>The following example shows how to use the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterReadLock">EnterReadLock()</a> method to enter the lock in read mode. The method shown in the example retrieves the value associated with a key. If the key is not found, the exception thrown by the inner <a class="xref" href="System.Collections.Generic.Dictionary%602.html#System_Collections_Generic_Dictionary_2">Dictionary<tkey, tvalue=""></tkey,></a> is allowed to terminate the method. A <strong>finally</strong> block is used to execute the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_ExitReadLock">ExitReadLock()</a> method, ensuring that the caller exits read mode.</p>
<p>This code is part of a larger example provided for the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> class.</p>System.Threading.ReaderWriterLockSlim_Shadow#2,3
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.LockRecursionException.html#System_Threading_LockRecursionException">LockRecursionException</a></td>
                    <td><p>The current thread cannot acquire the write lock when it holds the read lock.</p>
<p>-or-</p>
<p>The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_RecursionPolicy">RecursionPolicy</a> property is <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy_NoRecursion">NoRecursion</a>, and the current thread has attempted to acquire the read lock when it already holds the read lock. </p>
<p>-or-</p>
<p>The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_RecursionPolicy">RecursionPolicy</a> property is <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy_NoRecursion">NoRecursion</a>, and the current thread has attempted to acquire the read lock when it already holds the write lock. </p>
<p>-or-</p>
<p>The recursion number would exceed the capacity of the counter. This limit is so large that applications should never encounter this exception. </p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.ObjectDisposedException.html#System_ObjectDisposedException">ObjectDisposedException</a></td>
                    <td><p>The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> object has been disposed. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_EnterUpgradeableReadLock.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L233">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_EnterUpgradeableReadLock" data-uid="System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">EnterUpgradeableReadLock()</h4>
              <div class="markdown level1 summary"><p>Tries to enter the lock in upgradeable mode.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_EnterUpgradeableReadLock_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method blocks until the calling thread enters the lock, and therefore might never return. Use the <see cref="Overload:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock"></see> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.</p>
<p>Use upgradeable mode when a thread usually accesses the resource that is protected by the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> in read mode, but may need to enter write mode if certain conditions are met. A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.</p>
<p>Only one thread can enter upgradeable mode at any given time. If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</p>
<p>If one or more threads are waiting to enter write mode, a thread that calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterUpgradeableReadLock">EnterUpgradeableReadLock()</a> method blocks until those threads have either timed out or entered write mode and then exited from it.</p>
<p>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode. </p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public void EnterUpgradeableReadLock()</code></pre>
              </div>
              <h5 id="System_Threading_ReaderWriterLockSlim_EnterUpgradeableReadLock_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method blocks until the calling thread enters the lock, and therefore might never return. Use the <see cref="Overload:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock"></see> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.</p>
<p>Use upgradeable mode when a thread usually accesses the resource that is protected by the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> in read mode, but may need to enter write mode if certain conditions are met. A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.</p>
<p>Only one thread can enter upgradeable mode at any given time. If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</p>
<p>If one or more threads are waiting to enter write mode, a thread that calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterUpgradeableReadLock">EnterUpgradeableReadLock()</a> method blocks until those threads have either timed out or entered write mode and then exited from it.</p>
<p>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode. </p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_EnterUpgradeableReadLock_examples">Examples</h5>
              
<p>The following example shows how to use the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterUpgradeableReadLock">EnterUpgradeableReadLock()</a> method to enter the lock in upgradeable mode. A <strong>finally</strong> block is used to execute the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_ExitUpgradeableReadLock">ExitUpgradeableReadLock()</a> method, ensuring that the caller exits upgradeable mode.</p>
<p>The method shown in the example retrieves the value associated with a key and compares it with a new value. If the value is unchanged, the method returns a status indicating no change. It no value is found for the key, the key/value pair is inserted. If the value has changed, it is updated. Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</p>
<p>The example uses the default constructor to create the lock, so recursion is not allowed. Programming the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is simpler and less prone to error when the lock does not allow recursion. </p>
<p>This code is part of a larger example provided for the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> class.</p>System.Threading.ReaderWriterLockSlim_Shadow#2,6,10
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.LockRecursionException.html#System_Threading_LockRecursionException">LockRecursionException</a></td>
                    <td><p>The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_RecursionPolicy">RecursionPolicy</a> property is <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy_NoRecursion">NoRecursion</a> and the current thread has already entered the lock in any mode. </p>
<p>-or-</p>
<p>The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock. </p>
<p>-or-</p>
<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.ObjectDisposedException.html#System_ObjectDisposedException">ObjectDisposedException</a></td>
                    <td><p>The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> object has been disposed. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_EnterWriteLock.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.EnterWriteLock%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L234">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_EnterWriteLock" data-uid="System.Threading.ReaderWriterLockSlim.EnterWriteLock">EnterWriteLock()</h4>
              <div class="markdown level1 summary"><p>Tries to enter the lock in write mode.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_EnterWriteLock_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method blocks until the calling thread enters the lock, and therefore might never return. Use the <see cref="Overload:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock"></see> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.</p>
<p>If other threads have entered the lock in read mode, a thread that calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterWriteLock">EnterWriteLock()</a> method blocks until those threads have exited read mode. When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</p>
<p>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode. </p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public void EnterWriteLock()</code></pre>
              </div>
              <h5 id="System_Threading_ReaderWriterLockSlim_EnterWriteLock_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method blocks until the calling thread enters the lock, and therefore might never return. Use the <see cref="Overload:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock"></see> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.</p>
<p>If other threads have entered the lock in read mode, a thread that calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterWriteLock">EnterWriteLock()</a> method blocks until those threads have exited read mode. When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</p>
<p>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode. </p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_EnterWriteLock_examples">Examples</h5>
              
<p>The following example shows how to use the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterWriteLock">EnterWriteLock()</a> method to enter the lock in write mode. The method shown in the example adds a new key/value pair to the synchronized cache. If the key is already in the cache, the exception thrown by the inner <a class="xref" href="System.Collections.Generic.Dictionary%602.html#System_Collections_Generic_Dictionary_2">Dictionary<tkey, tvalue=""></tkey,></a> is allowed to terminate the method. A <strong>finally</strong> block is used to execute the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_ExitWriteLock">ExitWriteLock()</a> method, ensuring that the caller exits write mode.</p>
<p>This code is part of a larger example provided for the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> class.</p>System.Threading.ReaderWriterLockSlim_Shadow#2,4
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.LockRecursionException.html#System_Threading_LockRecursionException">LockRecursionException</a></td>
                    <td><p>The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_RecursionPolicy">RecursionPolicy</a> property is <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy_NoRecursion">NoRecursion</a> and the current thread has already entered the lock in any mode. </p>
<p>-or-</p>
<p>The current thread has entered read mode, so trying to enter the lock in write mode would create the possibility of a deadlock. </p>
<p>-or-</p>
<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.ObjectDisposedException.html#System_ObjectDisposedException">ObjectDisposedException</a></td>
                    <td><p>The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> object has been disposed. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_ExitReadLock.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.ExitReadLock%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L235">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_ExitReadLock" data-uid="System.Threading.ReaderWriterLockSlim.ExitReadLock">ExitReadLock()</h4>
              <div class="markdown level1 summary"><p>Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_ExitReadLock_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method is not sensitive to recursion order. For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter. If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter. </p>
<p>Exiting the lock might signal other waiting threads.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public void ExitReadLock()</code></pre>
              </div>
              <h5 id="System_Threading_ReaderWriterLockSlim_ExitReadLock_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method is not sensitive to recursion order. For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter. If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter. </p>
<p>Exiting the lock might signal other waiting threads.</p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_ExitReadLock_examples">Examples</h5>
              
<p>The following example shows how to use a <strong>finally</strong> block to execute the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_ExitReadLock">ExitReadLock()</a> method, ensuring that the caller exits read mode. The method shown in the example retrieves the value associated with a key. If the key is not found, the exception thrown by the inner <a class="xref" href="System.Collections.Generic.Dictionary%602.html#System_Collections_Generic_Dictionary_2">Dictionary<tkey, tvalue=""></tkey,></a> is allowed to terminate the method. The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterReadLock">EnterReadLock()</a> method is used to enter read mode.</p>
<p>This code is part of a larger example provided for the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> class.</p>System.Threading.ReaderWriterLockSlim_Shadow#2,3
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.SynchronizationLockException.html#System_Threading_SynchronizationLockException">SynchronizationLockException</a></td>
                    <td><p>The current thread has not entered the lock in read mode. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_ExitUpgradeableReadLock.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L236">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_ExitUpgradeableReadLock" data-uid="System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">ExitUpgradeableReadLock()</h4>
              <div class="markdown level1 summary"><p>Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_ExitUpgradeableReadLock_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method is not sensitive to recursion order. For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter. If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter. </p>
<p>Exiting the lock might signal other waiting threads.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public void ExitUpgradeableReadLock()</code></pre>
              </div>
              <h5 id="System_Threading_ReaderWriterLockSlim_ExitUpgradeableReadLock_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method is not sensitive to recursion order. For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter. If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter. </p>
<p>Exiting the lock might signal other waiting threads.</p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_ExitUpgradeableReadLock_examples">Examples</h5>
              
<p>The following example shows how to use a <strong>finally</strong> block to execute the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_ExitUpgradeableReadLock">ExitUpgradeableReadLock()</a> method, ensuring that the caller exits upgradeable mode.</p>
<p>The method shown in the example retrieves the value associated with a key and compares it with a new value. If the value is unchanged, the method returns a status indicating no change. It no value is found for the key, the key/value pair is inserted. If the value has changed, it is updated. Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</p>
<p>The example uses the default constructor to create the lock, so recursion is not allowed. Programming the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is simpler and less prone to error when the lock does not allow recursion. </p>
<p>This code is part of a larger example provided for the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> class.</p>System.Threading.ReaderWriterLockSlim_Shadow#2,6,10
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.SynchronizationLockException.html#System_Threading_SynchronizationLockException">SynchronizationLockException</a></td>
                    <td><p>The current thread has not entered the lock in upgradeable mode.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_ExitWriteLock.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.ExitWriteLock%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L237">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_ExitWriteLock" data-uid="System.Threading.ReaderWriterLockSlim.ExitWriteLock">ExitWriteLock()</h4>
              <div class="markdown level1 summary"><p>Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_ExitWriteLock_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method is not sensitive to recursion order. For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter. If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter. </p>
<p>Exiting the lock might signal other waiting threads.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public void ExitWriteLock()</code></pre>
              </div>
              <h5 id="System_Threading_ReaderWriterLockSlim_ExitWriteLock_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>This method is not sensitive to recursion order. For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter. If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter. </p>
<p>Exiting the lock might signal other waiting threads.</p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_ExitWriteLock_examples">Examples</h5>
              
<p>The following example shows how to use a <strong>finally</strong> block to execute the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_ExitWriteLock">ExitWriteLock()</a> method, ensuring that the caller exits write mode. The method shown in the example adds a new key/value pair to the synchronized cache. If the key is already in the cache, the exception thrown by the inner <a class="xref" href="System.Collections.Generic.Dictionary%602.html#System_Collections_Generic_Dictionary_2">Dictionary<tkey, tvalue=""></tkey,></a> is allowed to terminate the method. The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterWriteLock">EnterWriteLock()</a> method is used to enter the lock in write mode.</p>
<p>This code is part of a larger example provided for the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> class.</p>System.Threading.ReaderWriterLockSlim_Shadow#2,4
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.SynchronizationLockException.html#System_Threading_SynchronizationLockException">SynchronizationLockException</a></td>
                    <td><p>The current thread has not entered the lock in write mode.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_TryEnterReadLock_System_Int32_.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L238">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_TryEnterReadLock_System_Int32_" data-uid="System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">TryEnterReadLock(Int32)</h4>
              <div class="markdown level1 summary"><p>Tries to enter the lock in read mode, with an optional integer time-out.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_TryEnterReadLock_System_Int32__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>millisecondsTimeout</em> is 0 (zero), this method checks the lock state and returns <strong>false</strong> immediately if the desired state is unavailable.</p>
<p>Multiple threads can enter read mode at the same time.</p>
<p>If one or more threads are waiting to enter write mode, a thread that calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_TryEnterReadLock_System_Int32_">TryEnterReadLock(Int32)</a> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread&#39;s own time-out interval expires.</p>
<p>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode. </p>
<p>One thread can be in upgradeable mode while other threads are in read mode. If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_TryEnterReadLock_System_Int32_">TryEnterReadLock(Int32)</a> method enter read mode immediately and do not block.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public bool TryEnterReadLock(int millisecondsTimeout)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td><em>millisecondsTimeout</em></td>
                    <td><p>The number of milliseconds to wait, or -1 (<a class="xref" href="System.Threading.Timeout.html#System_Threading_Timeout_Infinite">Infinite</a>) to wait indefinitely.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td><p>
<strong>true</strong> if the calling thread entered read mode, otherwise, <strong>false</strong>.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ReaderWriterLockSlim_TryEnterReadLock_System_Int32__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>millisecondsTimeout</em> is 0 (zero), this method checks the lock state and returns <strong>false</strong> immediately if the desired state is unavailable.</p>
<p>Multiple threads can enter read mode at the same time.</p>
<p>If one or more threads are waiting to enter write mode, a thread that calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_TryEnterReadLock_System_Int32_">TryEnterReadLock(Int32)</a> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread&#39;s own time-out interval expires.</p>
<p>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode. </p>
<p>One thread can be in upgradeable mode while other threads are in read mode. If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_TryEnterReadLock_System_Int32_">TryEnterReadLock(Int32)</a> method enter read mode immediately and do not block.</p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_TryEnterReadLock_System_Int32__examples">Examples</h5>
              <p>The following example shows a simple synchronized cache that holds strings with integer keys. An instance of <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is used to synchronize access to the <a class="xref" href="System.Collections.Generic.Dictionary%602.html#System_Collections_Generic_Dictionary_2">Dictionary<tkey, tvalue=""></tkey,></a> that serves as the inner cache. </p>
<p>The example includes simple methods to add to the cache, delete from the cache, and read from the cache. To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out. </p>
<p>To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value. If the value is unchanged, the method returns a status indicating no change. It no value is found for the key, the key/value pair is inserted. If the value has changed, it is updated. Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</p>
<p>The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode. </p>
<p>The example uses the default constructor to create the lock, so recursion is not allowed. Programming the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is simpler and less prone to error when the lock does not allow recursion. </p>System.Threading.ReaderWriterLockSlim_Shadow#11,12<p>The following code then uses the <code>SynchronizedCache</code> object to store a dictionary of vegetable names. It creates three tasks. The first writes the names of vegetables stored in an array to a <code>SynchronizedCache</code> instance. The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order. The final task searches for the string "cucumber" and, when it finds it, calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterUpgradeableReadLock">EnterUpgradeableReadLock()</a> method  to substitute the string "green bean". </p>System.Threading.ReaderWriterLockSlim_Shadow#11,13
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.LockRecursionException.html#System_Threading_LockRecursionException">LockRecursionException</a></td>
                    <td><p>The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_RecursionPolicy">RecursionPolicy</a> property is <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy_NoRecursion">NoRecursion</a> and the current thread has already entered the lock. </p>
<p>-or-</p>
<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.ArgumentOutOfRangeException.html#System_ArgumentOutOfRangeException">ArgumentOutOfRangeException</a></td>
                    <td><p>The value of <em>millisecondsTimeout</em> is negative, but it is not equal to <a class="xref" href="System.Threading.Timeout.html#System_Threading_Timeout_Infinite">Infinite</a> (-1), which is the only negative value allowed.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.ObjectDisposedException.html#System_ObjectDisposedException">ObjectDisposedException</a></td>
                    <td><p>The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> object has been disposed. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_TryEnterReadLock_System_TimeSpan_.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L239">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_TryEnterReadLock_System_TimeSpan_" data-uid="System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">TryEnterReadLock(TimeSpan)</h4>
              <div class="markdown level1 summary"><p>Tries to enter the lock in read mode, with an optional time-out.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_TryEnterReadLock_System_TimeSpan__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>timeout</em> is 0 (zero), this method checks the lock state and returns <strong>false</strong> immediately if the desired state is unavailable.</p>
<p>Multiple threads can enter the lock in read mode at the same time.</p>
<p>If one or more threads are queued to enter write mode, a thread that calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_TryEnterReadLock_System_TimeSpan_">TryEnterReadLock(TimeSpan)</a> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread&#39;s own time-out interval expires.</p>
<p>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode. </p>
<p>One thread can be in upgradeable mode while other threads are in read mode. If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_TryEnterReadLock_System_TimeSpan_">TryEnterReadLock(TimeSpan)</a> method enter read mode immediately and do not block.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public bool TryEnterReadLock(TimeSpan timeout)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.TimeSpan.html#System_TimeSpan">TimeSpan</a></td>
                    <td><em>timeout</em></td>
                    <td><p>The interval to wait, or -1 milliseconds to wait indefinitely. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td><p>
<strong>true</strong> if the calling thread entered read mode, otherwise, <strong>false</strong>.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ReaderWriterLockSlim_TryEnterReadLock_System_TimeSpan__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>timeout</em> is 0 (zero), this method checks the lock state and returns <strong>false</strong> immediately if the desired state is unavailable.</p>
<p>Multiple threads can enter the lock in read mode at the same time.</p>
<p>If one or more threads are queued to enter write mode, a thread that calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_TryEnterReadLock_System_TimeSpan_">TryEnterReadLock(TimeSpan)</a> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread&#39;s own time-out interval expires.</p>
<p>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode. </p>
<p>One thread can be in upgradeable mode while other threads are in read mode. If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_TryEnterReadLock_System_TimeSpan_">TryEnterReadLock(TimeSpan)</a> method enter read mode immediately and do not block.</p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_TryEnterReadLock_System_TimeSpan__examples">Examples</h5>
              <p>The following example shows a simple synchronized cache that holds strings with integer keys. An instance of <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is used to synchronize access to the <a class="xref" href="System.Collections.Generic.Dictionary%602.html#System_Collections_Generic_Dictionary_2">Dictionary<tkey, tvalue=""></tkey,></a> that serves as the inner cache. </p>
<p>The example includes simple methods to add to the cache, delete from the cache, and read from the cache. To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out. </p>
<p>To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value. If the value is unchanged, the method returns a status indicating no change. It no value is found for the key, the key/value pair is inserted. If the value has changed, it is updated. Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</p>
<p>The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode. </p>
<p>The example uses the default constructor to create the lock, so recursion is not allowed. Programming the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is simpler and less prone to error when the lock does not allow recursion. </p>System.Threading.ReaderWriterLockSlim_Shadow#11,12<p>The following code then uses the <code>SynchronizedCache</code> object to store a dictionary of vegetable names. It creates three tasks. The first writes the names of vegetables stored in an array to a <code>SynchronizedCache</code> instance. The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order. The final task searches for the string "cucumber" and, when it finds it, calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterUpgradeableReadLock">EnterUpgradeableReadLock()</a> method  to substitute the string "green bean". </p>System.Threading.ReaderWriterLockSlim_Shadow#11,13
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.LockRecursionException.html#System_Threading_LockRecursionException">LockRecursionException</a></td>
                    <td><p>The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_RecursionPolicy">RecursionPolicy</a> property is <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy_NoRecursion">NoRecursion</a> and the current thread has already entered the lock. </p>
<p>-or-</p>
<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.ArgumentOutOfRangeException.html#System_ArgumentOutOfRangeException">ArgumentOutOfRangeException</a></td>
                    <td><p>The value of <em>timeout</em> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</p>
<p>-or-</p>
<p>The value of <em>timeout</em> is greater than <a class="xref" href="System.Int32.html#System_Int32_MaxValue">MaxValue</a> milliseconds. </p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.ObjectDisposedException.html#System_ObjectDisposedException">ObjectDisposedException</a></td>
                    <td><p>The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> object has been disposed. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_TryEnterUpgradeableReadLock_System_Int32_.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L240">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_TryEnterUpgradeableReadLock_System_Int32_" data-uid="System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">TryEnterUpgradeableReadLock(Int32)</h4>
              <div class="markdown level1 summary"><p>Tries to enter the lock in upgradeable mode, with an optional time-out.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_TryEnterUpgradeableReadLock_System_Int32__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>millisecondsTimeout</em> is 0 (zero), this method checks the lock state and returns <strong>false</strong> immediately if the desired state is unavailable.</p>
<p>Use upgradeable mode when a thread usually accesses the resource that is protected by the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> in read mode, but may need to enter write mode if certain conditions are met. A thread in upgradeable mode can upgrade to write mode or downgrade to read mode. </p>
<p>Only one thread can enter a lock in upgradeable mode at any given time. If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</p>
<p>If one or more threads are waiting to enter write mode, a thread that calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_TryEnterUpgradeableReadLock_System_Int32_">TryEnterUpgradeableReadLock(Int32)</a> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread&#39;s own time-out interval expires.</p>
<p>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode. </p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public bool TryEnterUpgradeableReadLock(int millisecondsTimeout)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td><em>millisecondsTimeout</em></td>
                    <td><p>The number of milliseconds to wait, or -1 (<a class="xref" href="System.Threading.Timeout.html#System_Threading_Timeout_Infinite">Infinite</a>) to wait indefinitely.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td><p>
<strong>true</strong> if the calling thread entered upgradeable mode, otherwise, <strong>false</strong>.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ReaderWriterLockSlim_TryEnterUpgradeableReadLock_System_Int32__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>millisecondsTimeout</em> is 0 (zero), this method checks the lock state and returns <strong>false</strong> immediately if the desired state is unavailable.</p>
<p>Use upgradeable mode when a thread usually accesses the resource that is protected by the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> in read mode, but may need to enter write mode if certain conditions are met. A thread in upgradeable mode can upgrade to write mode or downgrade to read mode. </p>
<p>Only one thread can enter a lock in upgradeable mode at any given time. If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</p>
<p>If one or more threads are waiting to enter write mode, a thread that calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_TryEnterUpgradeableReadLock_System_Int32_">TryEnterUpgradeableReadLock(Int32)</a> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread&#39;s own time-out interval expires.</p>
<p>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode. </p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_TryEnterUpgradeableReadLock_System_Int32__examples">Examples</h5>
              <p>The following example shows a simple synchronized cache that holds strings with integer keys. An instance of <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is used to synchronize access to the <a class="xref" href="System.Collections.Generic.Dictionary%602.html#System_Collections_Generic_Dictionary_2">Dictionary<tkey, tvalue=""></tkey,></a> that serves as the inner cache. </p>
<p>The example includes simple methods to add to the cache, delete from the cache, and read from the cache. To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out. </p>
<p>To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value. If the value is unchanged, the method returns a status indicating no change. It no value is found for the key, the key/value pair is inserted. If the value has changed, it is updated. Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</p>
<p>The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode. </p>
<p>The example uses the default constructor to create the lock, so recursion is not allowed. Programming the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is simpler and less prone to error when the lock does not allow recursion. </p>System.Threading.ReaderWriterLockSlim_Shadow#11,12<p>The following code then uses the <code>SynchronizedCache</code> object to store a dictionary of vegetable names. It creates three tasks. The first writes the names of vegetables stored in an array to a <code>SynchronizedCache</code> instance. The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order. The final task searches for the string "cucumber" and, when it finds it, calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterUpgradeableReadLock">EnterUpgradeableReadLock()</a> method  to substitute the string "green bean". </p>System.Threading.ReaderWriterLockSlim_Shadow#11,13
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.LockRecursionException.html#System_Threading_LockRecursionException">LockRecursionException</a></td>
                    <td><p>The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_RecursionPolicy">RecursionPolicy</a> property is <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy_NoRecursion">NoRecursion</a> and the current thread has already entered the lock. </p>
<p>-or-</p>
<p>The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock. </p>
<p>-or-</p>
<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.ArgumentOutOfRangeException.html#System_ArgumentOutOfRangeException">ArgumentOutOfRangeException</a></td>
                    <td><p>The value of <em>millisecondsTimeout</em> is negative, but it is not equal to <a class="xref" href="System.Threading.Timeout.html#System_Threading_Timeout_Infinite">Infinite</a> (-1), which is the only negative value allowed. </p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.ObjectDisposedException.html#System_ObjectDisposedException">ObjectDisposedException</a></td>
                    <td><p>The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> object has been disposed. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_TryEnterUpgradeableReadLock_System_TimeSpan_.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L241">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_TryEnterUpgradeableReadLock_System_TimeSpan_" data-uid="System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">TryEnterUpgradeableReadLock(TimeSpan)</h4>
              <div class="markdown level1 summary"><p>Tries to enter the lock in upgradeable mode, with an optional time-out.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_TryEnterUpgradeableReadLock_System_TimeSpan__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>timeout</em> is 0 (zero), this method checks the lock state and returns <strong>false</strong> immediately if the desired state is unavailable.</p>
<p>Use upgradeable mode when a thread usually accesses the resource protected by the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> in read mode, but may need to enter write mode if certain conditions are met. A thread in upgradeable mode can upgrade to write mode or downgrade to read mode. </p>
<p>Only one thread can enter a lock in upgradeable mode at any given time. If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</p>
<p>If one or more threads are waiting to enter write mode, a thread that calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_TryEnterUpgradeableReadLock_System_Int32_">TryEnterUpgradeableReadLock(Int32)</a> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread&#39;s own time-out interval expires.</p>
<p>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode. </p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public bool TryEnterUpgradeableReadLock(TimeSpan timeout)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.TimeSpan.html#System_TimeSpan">TimeSpan</a></td>
                    <td><em>timeout</em></td>
                    <td><p>The interval to wait, or -1 milliseconds to wait indefinitely.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td><p>
<strong>true</strong> if the calling thread entered upgradeable mode, otherwise, <strong>false</strong>.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ReaderWriterLockSlim_TryEnterUpgradeableReadLock_System_TimeSpan__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>timeout</em> is 0 (zero), this method checks the lock state and returns <strong>false</strong> immediately if the desired state is unavailable.</p>
<p>Use upgradeable mode when a thread usually accesses the resource protected by the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> in read mode, but may need to enter write mode if certain conditions are met. A thread in upgradeable mode can upgrade to write mode or downgrade to read mode. </p>
<p>Only one thread can enter a lock in upgradeable mode at any given time. If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</p>
<p>If one or more threads are waiting to enter write mode, a thread that calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_TryEnterUpgradeableReadLock_System_Int32_">TryEnterUpgradeableReadLock(Int32)</a> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread&#39;s own time-out interval expires.</p>
<p>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode. </p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_TryEnterUpgradeableReadLock_System_TimeSpan__examples">Examples</h5>
              <p>The following example shows a simple synchronized cache that holds strings with integer keys. An instance of <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is used to synchronize access to the <a class="xref" href="System.Collections.Generic.Dictionary%602.html#System_Collections_Generic_Dictionary_2">Dictionary<tkey, tvalue=""></tkey,></a> that serves as the inner cache. </p>
<p>The example includes simple methods to add to the cache, delete from the cache, and read from the cache. To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out. </p>
<p>To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value. If the value is unchanged, the method returns a status indicating no change. It no value is found for the key, the key/value pair is inserted. If the value has changed, it is updated. Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</p>
<p>The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode. </p>
<p>The example uses the default constructor to create the lock, so recursion is not allowed. Programming the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is simpler and less prone to error when the lock does not allow recursion. </p>System.Threading.ReaderWriterLockSlim_Shadow#11,12<p>The following code then uses the <code>SynchronizedCache</code> object to store a dictionary of vegetable names. It creates three tasks. The first writes the names of vegetables stored in an array to a <code>SynchronizedCache</code> instance. The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order. The final task searches for the string "cucumber" and, when it finds it, calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterUpgradeableReadLock">EnterUpgradeableReadLock()</a> method  to substitute the string "green bean". </p>System.Threading.ReaderWriterLockSlim_Shadow#11,13
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.LockRecursionException.html#System_Threading_LockRecursionException">LockRecursionException</a></td>
                    <td><p>The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_RecursionPolicy">RecursionPolicy</a> property is <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy_NoRecursion">NoRecursion</a> and the current thread has already entered the lock. </p>
<p>-or-</p>
<p>The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock. </p>
<p>-or-</p>
<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.ArgumentOutOfRangeException.html#System_ArgumentOutOfRangeException">ArgumentOutOfRangeException</a></td>
                    <td><p>The value of <em>timeout</em> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</p>
<p>-or-</p>
<p>The value of <em>timeout</em> is greater than <a class="xref" href="System.Int32.html#System_Int32_MaxValue">MaxValue</a> milliseconds. </p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.ObjectDisposedException.html#System_ObjectDisposedException">ObjectDisposedException</a></td>
                    <td><p>The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> object has been disposed. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_TryEnterWriteLock_System_Int32_.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L242">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_TryEnterWriteLock_System_Int32_" data-uid="System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">TryEnterWriteLock(Int32)</h4>
              <div class="markdown level1 summary"><p>Tries to enter the lock in write mode, with an optional time-out.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_TryEnterWriteLock_System_Int32__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>millisecondsTimeout</em> is 0 (zero), this method checks the lock state and returns <strong>false</strong> immediately if the desired state is unavailable.</p>
<p>If other threads have entered the lock in read mode, a thread that calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_TryEnterWriteLock_System_Int32_">TryEnterWriteLock(Int32)</a> method blocks until those threads have exited read mode or until the time-out interval has elapsed. While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</p>
<p>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode. </p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public bool TryEnterWriteLock(int millisecondsTimeout)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td><em>millisecondsTimeout</em></td>
                    <td><p>The number of milliseconds to wait, or -1 (<a class="xref" href="System.Threading.Timeout.html#System_Threading_Timeout_Infinite">Infinite</a>) to wait indefinitely.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td><p>
<strong>true</strong> if the calling thread entered write mode, otherwise, <strong>false</strong>.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ReaderWriterLockSlim_TryEnterWriteLock_System_Int32__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>millisecondsTimeout</em> is 0 (zero), this method checks the lock state and returns <strong>false</strong> immediately if the desired state is unavailable.</p>
<p>If other threads have entered the lock in read mode, a thread that calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_TryEnterWriteLock_System_Int32_">TryEnterWriteLock(Int32)</a> method blocks until those threads have exited read mode or until the time-out interval has elapsed. While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</p>
<p>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode. </p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_TryEnterWriteLock_System_Int32__examples">Examples</h5>
              
<p>The following example shows how to use the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_TryEnterWriteLock_System_Int32_">TryEnterWriteLock(Int32)</a> method to enter the lock in write mode, with a time-out. The method shown in the example adds a new key/value pair to the synchronized cache. If the specified time-out interval elapses before the thread enters the lock, the method returns <strong>false</strong>. The method returns <strong>true</strong> if the key/value pair is added.</p>
<p>If the key is already in the cache, the exception thrown by the inner <a class="xref" href="System.Collections.Generic.Dictionary%602.html#System_Collections_Generic_Dictionary_2">Dictionary<tkey, tvalue=""></tkey,></a> is allowed to terminate the method. A <strong>finally</strong> block is used to execute the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_ExitWriteLock">ExitWriteLock()</a> method, ensuring that the caller exits the lock.</p>
<p>This code is part of a larger example provided for the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> class.</p>System.Threading.ReaderWriterLockSlim_Shadow#2,5
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.LockRecursionException.html#System_Threading_LockRecursionException">LockRecursionException</a></td>
                    <td><p>The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_RecursionPolicy">RecursionPolicy</a> property is <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy_NoRecursion">NoRecursion</a> and the current thread has already entered the lock. </p>
<p>-or-</p>
<p>The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock. </p>
<p>-or-</p>
<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.ArgumentOutOfRangeException.html#System_ArgumentOutOfRangeException">ArgumentOutOfRangeException</a></td>
                    <td><p>The value of <em>millisecondsTimeout</em> is negative, but it is not equal to <a class="xref" href="System.Threading.Timeout.html#System_Threading_Timeout_Infinite">Infinite</a> (-1), which is the only negative value allowed. </p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.ObjectDisposedException.html#System_ObjectDisposedException">ObjectDisposedException</a></td>
                    <td><p>The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> object has been disposed. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ReaderWriterLockSlim_TryEnterWriteLock_System_TimeSpan_.md&amp;value=---%0Auid%3A%20System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/corefx/blob/master/src/System.Threading/ref/System.Threading.cs/#L243">View Source</a>
              </span>
              <h4 id="System_Threading_ReaderWriterLockSlim_TryEnterWriteLock_System_TimeSpan_" data-uid="System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">TryEnterWriteLock(TimeSpan)</h4>
              <div class="markdown level1 summary"><p>Tries to enter the lock in write mode, with an optional time-out.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ReaderWriterLockSlim_TryEnterWriteLock_System_TimeSpan__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>timeout</em> is 0 (zero), this method checks the lock state and returns <strong>false</strong> immediately if the desired state is unavailable.</p>
<p>If other threads have entered the lock in read mode, a thread that calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_TryEnterWriteLock_System_Int32_">TryEnterWriteLock(Int32)</a> method blocks until those threads have exited read mode or until the time-out interval has elapsed. While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</p>
<p>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode. </p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public bool TryEnterWriteLock(TimeSpan timeout)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.TimeSpan.html#System_TimeSpan">TimeSpan</a></td>
                    <td><em>timeout</em></td>
                    <td><p>The interval to wait, or -1 milliseconds to wait indefinitely.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td><p>
<strong>true</strong> if the calling thread entered write mode, otherwise, <strong>false</strong>.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ReaderWriterLockSlim_TryEnterWriteLock_System_TimeSpan__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>timeout</em> is 0 (zero), this method checks the lock state and returns <strong>false</strong> immediately if the desired state is unavailable.</p>
<p>If other threads have entered the lock in read mode, a thread that calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_TryEnterWriteLock_System_Int32_">TryEnterWriteLock(Int32)</a> method blocks until those threads have exited read mode or until the time-out interval has elapsed. While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</p>
<p>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode. </p>
</div>
              <h5 id="System_Threading_ReaderWriterLockSlim_TryEnterWriteLock_System_TimeSpan__examples">Examples</h5>
              <p>The following example shows a simple synchronized cache that holds strings with integer keys. An instance of <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is used to synchronize access to the <a class="xref" href="System.Collections.Generic.Dictionary%602.html#System_Collections_Generic_Dictionary_2">Dictionary<tkey, tvalue=""></tkey,></a> that serves as the inner cache. </p>
<p>The example includes simple methods to add to the cache, delete from the cache, and read from the cache. To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out. </p>
<p>To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value. If the value is unchanged, the method returns a status indicating no change. It no value is found for the key, the key/value pair is inserted. If the value has changed, it is updated. Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</p>
<p>The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode. </p>
<p>The example uses the default constructor to create the lock, so recursion is not allowed. Programming the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> is simpler and less prone to error when the lock does not allow recursion. </p>System.Threading.ReaderWriterLockSlim_Shadow#11,12<p>The following code then uses the <code>SynchronizedCache</code> object to store a dictionary of vegetable names. It creates three tasks. The first writes the names of vegetables stored in an array to a <code>SynchronizedCache</code> instance. The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order. The final task searches for the string "cucumber" and, when it finds it, calls the <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_EnterUpgradeableReadLock">EnterUpgradeableReadLock()</a> method  to substitute the string "green bean". </p>System.Threading.ReaderWriterLockSlim_Shadow#11,13
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.LockRecursionException.html#System_Threading_LockRecursionException">LockRecursionException</a></td>
                    <td><p>The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim_RecursionPolicy">RecursionPolicy</a> property is <a class="xref" href="System.Threading.LockRecursionPolicy.html#System_Threading_LockRecursionPolicy_NoRecursion">NoRecursion</a> and the current thread has already entered the lock. </p>
<p>-or-</p>
<p>The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock. </p>
<p>-or-</p>
<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.ArgumentOutOfRangeException.html#System_ArgumentOutOfRangeException">ArgumentOutOfRangeException</a></td>
                    <td><p>The value of <em>timeout</em> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</p>
<p>-or-</p>
<p>The value of <em>timeout</em> is greater than <a class="xref" href="System.Int32.html#System_Int32_MaxValue">MaxValue</a> milliseconds. </p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.ObjectDisposedException.html#System_ObjectDisposedException">ObjectDisposedException</a></td>
                    <td><p>The <a class="xref" href="System.Threading.ReaderWriterLockSlim.html#System_Threading_ReaderWriterLockSlim">ReaderWriterLockSlim</a> object has been disposed. </p>
</td>
                  </tr>
                </tbody>
              </table>
            </article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
            <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
            </nav>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="inner-footer">
          <p>© .NET Foundation</p>
          <p>
            <a href="https://www.github.com/dotnet" target="_blank"><span class="fa fa-stack fa-lg">
              <span class="fa fa-square-o fa-stack-2x"></span>
              <span class="fa fa-github fa-stack-1x"></span>
            </span></a>
            <a href="https://twitter.com/dotnet" target="_blank"><span class="fa fa-stack fa-lg">
              <span class="fa fa-square-o fa-stack-2x"></span>
              <span class="fa fa-twitter fa-stack-1x"></span>
            </span></a>
            <a href="https://www.facebook.com/dotnet" target="_blank"><span class="fa fa-stack fa-lg">
              <span class="fa fa-square-o fa-stack-2x"></span>
              <span class="fa fa-facebook fa-stack-1x"></span>
            </span></a>
      
          </p>
          </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
