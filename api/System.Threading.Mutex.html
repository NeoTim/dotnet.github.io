<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Class Mutex
   | CoreCLR site </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Class Mutex
   | CoreCLR site ">
    
    <link rel="shortcut icon" href="../images/Logo_DotNet.png" type="image/x-icon">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/main.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/style.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  
    ga('create', 'UA-63735192-1', 'auto');
    ga('send', 'pageview');
    </script>
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav class="navbar navbar-inverse">
             <div class="container">
               <a href="../"><img height="50px" src="../images/Logo_DotNet.png" style="float:right;"></a>
               <div class="navbar-header ">
                 <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                   <span class="sr-only">Toggle navigation</span>
                   <span class="icon-bar"></span>
                   <span class="icon-bar"></span>
                   <span class="icon-bar"></span>
                 </button>
                 <a class="navbar-brand" href="../"><span class="dotnet">.NET Core</span></a>
               </div>
               <div id="navbar" class="collapse navbar-collapse">
               </div><!--/.nav-collapse -->
             </div>
           </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content">
              
              <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Mutex.md&amp;value=---%0Auid%3A%20System.Threading.Mutex%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A" class="pull-right mobile-hide"><span class="fa fa-github"></span>Improve this Doc</a>
              <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/Mutex.cs/#L33" class="pull-right mobile-hide">View Source</a>
              <h1 id="System_Threading_Mutex" data-uid="System.Threading.Mutex">Class Mutex
              </h1>
              <div class="markdown level0 summary"><p>A synchronization primitive that can also be used for interprocess synchronization. </p>
</div>
              <div class="markdown level0 conceptual"></div>
              <div class="inheritance">
                <h5>Inheritance</h5>
                  <div class="level0"><a class="xref" href="System.Object.html#System_Object">Object</a></div>
                  <div class="level1"><span class="xref">System.MarshalByRefObject</span></div>
                  <div class="level2"><a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle">WaitHandle</a></div>
                  <div class="level3"><span class="xref">Mutex</span></div>
              </div>
              <div class="inheritedMembers">
                <h5>Inherited Members</h5>
                <div>
                  <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle_WaitTimeout">WaitTimeout</a>
                </div>
                <div>
                  <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle_InvalidHandle">InvalidHandle</a>
                </div>
                <div>
                  <span class="xref">System.Threading.WaitHandle.WaitOne(System.Int32, System.Boolean)</span>
                </div>
                <div>
                  <span class="xref">System.Threading.WaitHandle.WaitOne(System.TimeSpan, System.Boolean)</span>
                </div>
                <div>
                  <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle_WaitOne">WaitOne()</a>
                </div>
                <div>
                  <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle_WaitOne_System_Int32_">WaitOne(Int32)</a>
                </div>
                <div>
                  <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle_WaitOne_System_TimeSpan_">WaitOne(TimeSpan)</a>
                </div>
                <div>
                  <span class="xref">System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[], System.Int32, System.Boolean)</span>
                </div>
                <div>
                  <span class="xref">System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[], System.TimeSpan, System.Boolean)</span>
                </div>
                <div>
                  <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___">WaitAll(WaitHandle[])</a>
                </div>
                <div>
                  <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_Int32_">WaitAll(WaitHandle[], Int32)</a>
                </div>
                <div>
                  <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_TimeSpan_">WaitAll(WaitHandle[], TimeSpan)</a>
                </div>
                <div>
                  <span class="xref">System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[], System.Int32, System.Boolean)</span>
                </div>
                <div>
                  <span class="xref">System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[], System.TimeSpan, System.Boolean)</span>
                </div>
                <div>
                  <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_TimeSpan_">WaitAny(WaitHandle[], TimeSpan)</a>
                </div>
                <div>
                  <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___">WaitAny(WaitHandle[])</a>
                </div>
                <div>
                  <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_Int32_">WaitAny(WaitHandle[], Int32)</a>
                </div>
                <div>
                  <span class="xref">System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle, System.Threading.WaitHandle)</span>
                </div>
                <div>
                  <span class="xref">System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle, System.Threading.WaitHandle, System.TimeSpan, System.Boolean)</span>
                </div>
                <div>
                  <span class="xref">System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle, System.Threading.WaitHandle, System.Int32, System.Boolean)</span>
                </div>
                <div>
                  <span class="xref">System.Threading.WaitHandle.Close()</span>
                </div>
                <div>
                  <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle_Dispose_System_Boolean_">Dispose(Boolean)</a>
                </div>
                <div>
                  <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle_Dispose">Dispose()</a>
                </div>
                <div>
                  <span class="xref">System.Threading.WaitHandle.Handle</span>
                </div>
                <div>
                  <span class="xref">System.Threading.WaitHandle.SafeWaitHandle</span>
                </div>
                <div>
                  <span class="xref">System.MarshalByRefObject.MemberwiseClone(System.Boolean)</span>
                </div>
                <div>
                  <span class="xref">System.MarshalByRefObject.GetLifetimeService()</span>
                </div>
                <div>
                  <span class="xref">System.MarshalByRefObject.InitializeLifetimeService()</span>
                </div>
                <div>
                  <span class="xref">System.MarshalByRefObject.CreateObjRef(System.Type)</span>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_ToString">ToString()</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_Equals_System_Object_">Equals(Object)</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_Equals_System_Object_System_Object_">Equals(Object, Object)</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_ReferenceEquals_System_Object_System_Object_">ReferenceEquals(Object, Object)</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_GetHashCode">GetHashCode()</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_GetType">GetType()</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_MemberwiseClone">MemberwiseClone()</a>
                </div>
              </div>
              <h6><strong>Namespace</strong>:System.Threading</h6>
              <h6><strong>Assembly</strong>:System.Threading.dll</h6>
              <h5 id="System_Threading_Mutex_syntax">Syntax</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[HostProtection(Synchronization = true, ExternalThreading = true)]
[ComVisible(true)]
public sealed class Mutex : WaitHandle, IDisposable</code></pre>
              </div>
              <h5 id="System_Threading_Mutex_examples"><strong>Examples</strong></h5>
              
<p>This example shows how a local <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> object is used to synchronize access to a protected resource. Because each calling thread is blocked until it acquires ownership of the mutex, it must call the <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex_ReleaseMutex">ReleaseMutex()</a> method to release ownership of the thread. </p>System.Threading.Mutex.Class#1
              
<p>In the following example, each thread calls the <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle_WaitOne_System_Int32_">WaitOne(Int32)</a> method to acquire the mutex. If the time-out interval elapses, the method returns <strong>false</strong>, and the thread neither acquires the mutex nor gains access to the resource the mutex protects. The <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex_ReleaseMutex">ReleaseMutex()</a> method is called only by the thread that acquires the mutex. </p>System.Threading.Mutex.Class#2
              <h3 id="constructors">Constructors
              </h3>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Mutex__ctor.md&amp;value=---%0Auid%3A%20System.Threading.Mutex.%23ctor%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/Mutex.cs/#L252">View Source</a>
              </span>
              <h4 id="System_Threading_Mutex__ctor" data-uid="System.Threading.Mutex.#ctor">Mutex()</h4>
              <div class="markdown level1 summary"><p>Initializes a new instance of the <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> class with default properties.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Mutex__ctor_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Calling this constructor overload is the same as calling the <span class="xref">System.Threading.Mutex.</span> constructor overload and specifying <strong>false</strong> for initial ownership of the mutex. That is, the calling thread does not own the mutex.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[SecuritySafeCritical]
[ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
public Mutex()</code></pre>
              </div>
              <h5 id="System_Threading_Mutex__ctor_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Calling this constructor overload is the same as calling the <span class="xref">System.Threading.Mutex.</span> constructor overload and specifying <strong>false</strong> for initial ownership of the mutex. That is, the calling thread does not own the mutex.</p>
</div>
              <h5 id="System_Threading_Mutex__ctor_examples">Examples</h5>
              
<p>The following code example shows how a local <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> object is used to synchronize access to a protected resource. The thread that creates the mutex does not own it initially.</p>System.Threading.Mutex Default Ctor Example#1
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Mutex__ctor_System_Boolean_.md&amp;value=---%0Auid%3A%20System.Threading.Mutex.%23ctor(System.Boolean)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/Mutex.cs/#L246">View Source</a>
              </span>
              <h4 id="System_Threading_Mutex__ctor_System_Boolean_" data-uid="System.Threading.Mutex.#ctor(System.Boolean)">Mutex(Boolean)</h4>
              <div class="markdown level1 summary"><p>Initializes a new instance of the <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[SecuritySafeCritical]
[ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
public Mutex(bool initiallyOwned)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td><em>initiallyOwned</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Mutex__ctor_System_Boolean__examples">Examples</h5>
              
<p>The following code example shows how a local <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> object is used to synchronize access to a protected resource. The thread that creates the <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> owns it initially.</p>System.Threading.Mutex 1Arg Ctor Example#1
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Mutex__ctor_System_Boolean_System_String_.md&amp;value=---%0Auid%3A%20System.Threading.Mutex.%23ctor(System.Boolean%2CSystem.String)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/Mutex.cs/#L241">View Source</a>
              </span>
              <h4 id="System_Threading_Mutex__ctor_System_Boolean_System_String_" data-uid="System.Threading.Mutex.#ctor(System.Boolean,System.String)">Mutex(Boolean, String)</h4>
              <div class="markdown level1 summary"><p>Initializes a new instance of the <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Mutex__ctor_System_Boolean_System_String__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>name</em> is not <strong>null</strong> and <em>initiallyOwned</em> is <strong>true</strong>, the calling thread owns the mutex only if the named system mutex was created as a result of this call. Since there is no mechanism for determining whether the named system mutex was created, it is better to specify <strong>false</strong> for <em>initiallyOwned</em> when calling this constructor overload. You can use the <span class="xref">System.Threading.Mutex.</span> constructor if you need to determine initial ownership.</p>
<p>This constructor initializes a <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> object that represents a named system mutex. You can create multiple <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> objects that represent the same named system mutex.</p>
<p>If the named mutex has already been created with access control security, and the caller does not have <a class="xref" href="System.Security.AccessControl.MutexRights.html#System_Security_AccessControl_MutexRights_FullControl">FullControl</a>, an exception is thrown. To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <see cref="Overload:System.Threading.Mutex.OpenExisting"></see> method.</p>
<p>If you specify <strong>null</strong> or an empty string for <em>name</em>, a local mutex is created, as if you had called the <span class="xref">System.Threading.Mutex.</span> constructor. In this case, <em>createdNew</em> is always <strong>true</strong>.</p>
<p>Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</p>
<p>On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix &quot;Global\&quot;, the mutex is visible in all terminal server sessions. If its name begins with the prefix &quot;Local\&quot;, the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix &quot;Local\&quot;. Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names &quot;Global\&quot; and &quot;Local\&quot; describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[SecurityCritical]
[ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
public Mutex(bool initiallyOwned, string name)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td><em>initiallyOwned</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.String.html#System_String">String</a></td>
                    <td><em>name</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Mutex__ctor_System_Boolean_System_String__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>name</em> is not <strong>null</strong> and <em>initiallyOwned</em> is <strong>true</strong>, the calling thread owns the mutex only if the named system mutex was created as a result of this call. Since there is no mechanism for determining whether the named system mutex was created, it is better to specify <strong>false</strong> for <em>initiallyOwned</em> when calling this constructor overload. You can use the <span class="xref">System.Threading.Mutex.</span> constructor if you need to determine initial ownership.</p>
<p>This constructor initializes a <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> object that represents a named system mutex. You can create multiple <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> objects that represent the same named system mutex.</p>
<p>If the named mutex has already been created with access control security, and the caller does not have <a class="xref" href="System.Security.AccessControl.MutexRights.html#System_Security_AccessControl_MutexRights_FullControl">FullControl</a>, an exception is thrown. To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <see cref="Overload:System.Threading.Mutex.OpenExisting"></see> method.</p>
<p>If you specify <strong>null</strong> or an empty string for <em>name</em>, a local mutex is created, as if you had called the <span class="xref">System.Threading.Mutex.</span> constructor. In this case, <em>createdNew</em> is always <strong>true</strong>.</p>
<p>Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</p>
<p>On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix &quot;Global\&quot;, the mutex is visible in all terminal server sessions. If its name begins with the prefix &quot;Local\&quot;, the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix &quot;Local\&quot;. Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names &quot;Global\&quot; and &quot;Local\&quot; describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</p>
</div>
              <h5 id="System_Threading_Mutex__ctor_System_Boolean_System_String__examples">Examples</h5>
              
<p>The following example shows how a named mutex is used to signal between threads running in two separate processes. </p>
<p>Run this program from two or more command windows. Each process creates a <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> object that represents the named mutex <code>MyMutex</code>. The named mutex is a system object whose lifetime is bounded by the lifetimes of the <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> objects that represent it. The named mutex is created when the first process creates its <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> object; in this example, the named mutex is owned by the first process that runs the program. The named mutex is destroyed when all the <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> objects that represent it have been released.</p>
<p>The constructor overload used in this example cannot tell the calling thread whether initial ownership of the named mutex was granted. You should not use this constructor to request initial ownership unless you can be certain that the thread will create the named mutex.</p>System.Threading.Mutex 2Arg Ctor Example#1
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.UnauthorizedAccessException.html#System_UnauthorizedAccessException">UnauthorizedAccessException</a></td>
                    <td><p>The named mutex exists and has access control security, but the user does not have <a class="xref" href="System.Security.AccessControl.MutexRights.html#System_Security_AccessControl_MutexRights_FullControl">FullControl</a>.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.IO.IOException.html#System_IO_IOException">IOException</a></td>
                    <td><p>A Win32 error occurred.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Threading.WaitHandleCannotBeOpenedException.html#System_Threading_WaitHandleCannotBeOpenedException">WaitHandleCannotBeOpenedException</a></td>
                    <td><p>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.ArgumentException.html#System_ArgumentException">ArgumentException</a></td>
                    <td><p>
<em>name</em> is longer than 260 characters.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Mutex__ctor_System_Boolean_System_String_System_Boolean__.md&amp;value=---%0Auid%3A%20System.Threading.Mutex.%23ctor(System.Boolean%2CSystem.String%2CSystem.Boolean%40)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/Mutex.cs/#L44">View Source</a>
              </span>
              <h4 id="System_Threading_Mutex__ctor_System_Boolean_System_String_System_Boolean__" data-uid="System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">Mutex(Boolean, String, out Boolean)</h4>
              <div class="markdown level1 summary"><p>Initializes a new instance of the <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Mutex__ctor_System_Boolean_System_String_System_Boolean___remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>name</em> is not <strong>null</strong> and <em>initiallyOwned</em> is <strong>true</strong>, the calling thread owns the named mutex only if <em>createdNew</em> is <strong>true</strong> after the call. Otherwise the thread can request the mutex by calling the <see cref="Overload:System.Threading.WaitHandle.WaitOne"></see>method.</p>
<p>This constructor initializes a <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> object that represents a named system mutex. You can create multiple <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> objects that represent the same named system mutex.</p>
<p>If the named mutex has already been created with access control security, and the caller does not have <a class="xref" href="System.Security.AccessControl.MutexRights.html#System_Security_AccessControl_MutexRights_FullControl">FullControl</a> rights, an exception is thrown. To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <see cref="Overload:System.Threading.Mutex.OpenExisting"></see> method.</p>
<p>If you specify <strong>null</strong> or an empty string for <em>name</em>, a local mutex is created, as if you had called the <span class="xref">System.Threading.Mutex.</span> constructor. In this case, <em>createdNew</em> is always <strong>true</strong>.</p>
<p>Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</p>
<p>On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix &quot;Global\&quot;, the mutex is visible in all terminal server sessions. If its name begins with the prefix &quot;Local\&quot;, the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix &quot;Local\&quot;. Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names &quot;Global\&quot; and &quot;Local\&quot; describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[SecurityCritical]
[ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
public Mutex(bool initiallyOwned, string name, out bool createdNew)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td><em>initiallyOwned</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.String.html#System_String">String</a></td>
                    <td><em>name</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td><em>createdNew</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Mutex__ctor_System_Boolean_System_String_System_Boolean___remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If <em>name</em> is not <strong>null</strong> and <em>initiallyOwned</em> is <strong>true</strong>, the calling thread owns the named mutex only if <em>createdNew</em> is <strong>true</strong> after the call. Otherwise the thread can request the mutex by calling the <see cref="Overload:System.Threading.WaitHandle.WaitOne"></see>method.</p>
<p>This constructor initializes a <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> object that represents a named system mutex. You can create multiple <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> objects that represent the same named system mutex.</p>
<p>If the named mutex has already been created with access control security, and the caller does not have <a class="xref" href="System.Security.AccessControl.MutexRights.html#System_Security_AccessControl_MutexRights_FullControl">FullControl</a> rights, an exception is thrown. To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <see cref="Overload:System.Threading.Mutex.OpenExisting"></see> method.</p>
<p>If you specify <strong>null</strong> or an empty string for <em>name</em>, a local mutex is created, as if you had called the <span class="xref">System.Threading.Mutex.</span> constructor. In this case, <em>createdNew</em> is always <strong>true</strong>.</p>
<p>Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</p>
<p>On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix &quot;Global\&quot;, the mutex is visible in all terminal server sessions. If its name begins with the prefix &quot;Local\&quot;, the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix &quot;Local\&quot;. Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names &quot;Global\&quot; and &quot;Local\&quot; describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</p>
</div>
              <h5 id="System_Threading_Mutex__ctor_System_Boolean_System_String_System_Boolean___examples">Examples</h5>
              
<p>The following code example shows how a named mutex is used to signal between processes or threads. Run this program from two or more command windows. Each process creates a <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> object that represents the named mutex "MyMutex". The named mutex is a system object. In this example, its lifetime is bounded by the lifetimes of the <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> objects that represent it. The named mutex is created when the first process creates its local <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> object, and destroyed when all the <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> objects that represent it have been released. The named mutex is initially owned by the first process. The second process and any subsequent processes wait for earlier processes to release the named mutex.</p>System.Threading.Mutex 3Arg Ctor Example#1
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.UnauthorizedAccessException.html#System_UnauthorizedAccessException">UnauthorizedAccessException</a></td>
                    <td><p>The named mutex exists and has access control security, but the user does not have <a class="xref" href="System.Security.AccessControl.MutexRights.html#System_Security_AccessControl_MutexRights_FullControl">FullControl</a>.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.IO.IOException.html#System_IO_IOException">IOException</a></td>
                    <td><p>A Win32 error occurred.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Threading.WaitHandleCannotBeOpenedException.html#System_Threading_WaitHandleCannotBeOpenedException">WaitHandleCannotBeOpenedException</a></td>
                    <td><p>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.ArgumentException.html#System_ArgumentException">ArgumentException</a></td>
                    <td><p>
<em>name</em> is longer than 260 characters.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <h3 id="methods">Methods
              </h3>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Mutex_OpenExisting_System_String_.md&amp;value=---%0Auid%3A%20System.Threading.Mutex.OpenExisting(System.String)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/Mutex.cs/#L266">View Source</a>
              </span>
              <h4 id="System_Threading_Mutex_OpenExisting_System_String_" data-uid="System.Threading.Mutex.OpenExisting(System.String)">OpenExisting(String)</h4>
              <div class="markdown level1 summary"><p>Opens the specified named mutex, if it already exists.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Mutex_OpenExisting_System_String__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>The <see cref="Overload:System.Threading.Mutex.OpenExisting"></see> method tries to open the specified named system mutex. If the system mutex does not exist, this method throws an exception instead of creating the system object. To create the system mutex when it does not already exist, use one of the <span class="xref">System.Threading.Mutex.</span> constructors that has a <em>name</em> parameter.</p>
<p>Multiple calls to this method that use the same value for <em>name</em> do not necessarily return the same <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> object, even though the objects that are returned represent the same named system mutex. </p>
<p>This method overload is equivalent to calling the <span class="xref">System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)</span> method overload and specifying <a class="xref" href="System.Security.AccessControl.MutexRights.html#System_Security_AccessControl_MutexRights_Synchronize">Synchronize</a> and <a class="xref" href="System.Security.AccessControl.MutexRights.html#System_Security_AccessControl_MutexRights_Modify">Modify</a> rights, combined by using the bitwise OR operation. </p>
<p>Specifying the <a class="xref" href="System.Security.AccessControl.MutexRights.html#System_Security_AccessControl_MutexRights_Synchronize">Synchronize</a> flag allows a thread to wait on the mutex, and specifying the <a class="xref" href="System.Security.AccessControl.MutexRights.html#System_Security_AccessControl_MutexRights_Modify">Modify</a> flag allows a thread to call the <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex_ReleaseMutex">ReleaseMutex()</a> method.</p>
<p>This method does not request ownership of the mutex. </p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[SecurityCritical]
public static Mutex OpenExisting(string name)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.String.html#System_String">String</a></td>
                    <td><em>name</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Mutex_OpenExisting_System_String__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>The <see cref="Overload:System.Threading.Mutex.OpenExisting"></see> method tries to open the specified named system mutex. If the system mutex does not exist, this method throws an exception instead of creating the system object. To create the system mutex when it does not already exist, use one of the <span class="xref">System.Threading.Mutex.</span> constructors that has a <em>name</em> parameter.</p>
<p>Multiple calls to this method that use the same value for <em>name</em> do not necessarily return the same <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> object, even though the objects that are returned represent the same named system mutex. </p>
<p>This method overload is equivalent to calling the <span class="xref">System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)</span> method overload and specifying <a class="xref" href="System.Security.AccessControl.MutexRights.html#System_Security_AccessControl_MutexRights_Synchronize">Synchronize</a> and <a class="xref" href="System.Security.AccessControl.MutexRights.html#System_Security_AccessControl_MutexRights_Modify">Modify</a> rights, combined by using the bitwise OR operation. </p>
<p>Specifying the <a class="xref" href="System.Security.AccessControl.MutexRights.html#System_Security_AccessControl_MutexRights_Synchronize">Synchronize</a> flag allows a thread to wait on the mutex, and specifying the <a class="xref" href="System.Security.AccessControl.MutexRights.html#System_Security_AccessControl_MutexRights_Modify">Modify</a> flag allows a thread to call the <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex_ReleaseMutex">ReleaseMutex()</a> method.</p>
<p>This method does not request ownership of the mutex. </p>
</div>
              <h5 id="System_Threading_Mutex_OpenExisting_System_String__examples">Examples</h5>
              
<p>The following code example demonstrates the cross-process behavior of a named mutex with access control security. The example uses the <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex_OpenExisting_System_String_">OpenExisting(String)</a> method overload to test for the existence of a named mutex.</p>
<p>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex. </p>
<p>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex_OpenExisting_System_String_">OpenExisting(String)</a>. The exception is caught, and the example uses the <span class="xref">System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)</span> method overload to open the mutex with the rights needed to read and change the permissions. </p>
<p>After the permissions are changed, the mutex is opened with the rights required to enter and release it. If you run the compiled example from a third command window, it runs using the new permissions.</p>System.Threading.Mutex.ctor named 4#1
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.ArgumentException.html#System_ArgumentException">ArgumentException</a></td>
                    <td><p>
<em>name</em> is an empty string.</p>
<p>-or-</p>
<p>
<em>name</em> is longer than 260 characters.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.ArgumentNullException.html#System_ArgumentNullException">ArgumentNullException</a></td>
                    <td><p>
<em>name</em> is <strong>null</strong>.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Threading.WaitHandleCannotBeOpenedException.html#System_Threading_WaitHandleCannotBeOpenedException">WaitHandleCannotBeOpenedException</a></td>
                    <td><p>The named mutex does not exist.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.IO.IOException.html#System_IO_IOException">IOException</a></td>
                    <td><p>A Win32 error occurred.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.UnauthorizedAccessException.html#System_UnauthorizedAccessException">UnauthorizedAccessException</a></td>
                    <td><p>The named mutex exists, but the user does not have the security access required to use it.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Mutex_ReleaseMutex.md&amp;value=---%0Auid%3A%20System.Threading.Mutex.ReleaseMutex%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/Mutex.cs/#L382">View Source</a>
              </span>
              <h4 id="System_Threading_Mutex_ReleaseMutex" data-uid="System.Threading.Mutex.ReleaseMutex">ReleaseMutex()</h4>
              <div class="markdown level1 summary"><p>Releases the <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> once.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Mutex_ReleaseMutex_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Whenever a thread acquires a mutex (for example, by calling its <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle_WaitOne">WaitOne()</a> method), it must subsequently call <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex_ReleaseMutex">ReleaseMutex()</a> to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex. If the attempt to get ownership of the mutex fails (for example, when a call to the <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle_WaitOne">WaitOne()</a> method with a <em>millisecondsTimeout</em> or a <em>timeout</em> parameter returns <strong>false</strong> because the request times out), the thread shouldn&#39;t call <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex_ReleaseMutex">ReleaseMutex()</a>, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows.  </p>System.Threading.Mutex.Class#2<p>A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution. The number of calls is kept by the common language runtime. The thread must call <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex_ReleaseMutex">ReleaseMutex()</a> the same number of times to release ownership of the mutex. </p><p>If a thread terminates while owning a mutex, the mutex is said to be abandoned. The state of the mutex is set to signaled and the next waiting thread gets ownership. If no one owns the mutex, the state of the mutex is signaled. Beginning in version 2.0 of the .NET Framework, an <a class="xref" href="System.Threading.AbandonedMutexException.html#System_Threading_AbandonedMutexException">AbandonedMutexException</a> is thrown in the next thread that acquires the mutex. Prior to version 2.0 of the .NET Framework, no exception was thrown.</p><p>An abandoned mutex often indicates a serious error in the code. When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state. The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified. </p><p>In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</p></div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[SecuritySafeCritical]
[ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
public void ReleaseMutex()</code></pre>
              </div>
              <h5 id="System_Threading_Mutex_ReleaseMutex_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Whenever a thread acquires a mutex (for example, by calling its <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle_WaitOne">WaitOne()</a> method), it must subsequently call <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex_ReleaseMutex">ReleaseMutex()</a> to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex. If the attempt to get ownership of the mutex fails (for example, when a call to the <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle_WaitOne">WaitOne()</a> method with a <em>millisecondsTimeout</em> or a <em>timeout</em> parameter returns <strong>false</strong> because the request times out), the thread shouldn&#39;t call <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex_ReleaseMutex">ReleaseMutex()</a>, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows.  </p>System.Threading.Mutex.Class#2<p>A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution. The number of calls is kept by the common language runtime. The thread must call <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex_ReleaseMutex">ReleaseMutex()</a> the same number of times to release ownership of the mutex. </p><p>If a thread terminates while owning a mutex, the mutex is said to be abandoned. The state of the mutex is set to signaled and the next waiting thread gets ownership. If no one owns the mutex, the state of the mutex is signaled. Beginning in version 2.0 of the .NET Framework, an <a class="xref" href="System.Threading.AbandonedMutexException.html#System_Threading_AbandonedMutexException">AbandonedMutexException</a> is thrown in the next thread that acquires the mutex. Prior to version 2.0 of the .NET Framework, no exception was thrown.</p><p>An abandoned mutex often indicates a serious error in the code. When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state. The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified. </p><p>In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</p></div>
              <h5 id="System_Threading_Mutex_ReleaseMutex_examples">Examples</h5>
              
<p>The following example shows how a local <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> object is used to synchronize access to a protected resource. The thread that creates the mutex does not own it initially. The <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex_ReleaseMutex">ReleaseMutex()</a> method is used to release the mutex when it is no longer needed.</p>System.Threading.Mutex Default Ctor Example#1
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><span class="xref">System.ApplicationException</span></td>
                    <td><p>The calling thread does not own the mutex. </p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.ObjectDisposedException.html#System_ObjectDisposedException">ObjectDisposedException</a></td>
                    <td><p>The current instance has already been disposed. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_Mutex_TryOpenExisting_System_String_System_Threading_Mutex__.md&amp;value=---%0Auid%3A%20System.Threading.Mutex.TryOpenExisting(System.String%2CSystem.Threading.Mutex%40)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/Mutex.cs/#L303">View Source</a>
              </span>
              <h4 id="System_Threading_Mutex_TryOpenExisting_System_String_System_Threading_Mutex__" data-uid="System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">TryOpenExisting(String, out Mutex)</h4>
              <div class="markdown level1 summary"><p>Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_Mutex_TryOpenExisting_System_String_System_Threading_Mutex___remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If the named mutex does not exist, this method does not create it. To create the system mutex when it does not already exist, use one of the <span class="xref">System.Threading.Mutex.</span> constructors that has a <em>name</em> parameter.</p>
<p>If you are uncertain whether a named mutex exists, use this method overload instead of the <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex_OpenExisting_System_String_">OpenExisting(String)</a> method overload, which throws an exception if the mutex does not exist.</p>
<p>Multiple calls to this method that use the same value for <em>name</em> do not necessarily return the same <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> object, even though the objects that are returned represent the same named system mutex. </p>
<p>This method overload is equivalent to calling the <span class="xref">System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)</span> method overload and specifying <a class="xref" href="System.Security.AccessControl.MutexRights.html#System_Security_AccessControl_MutexRights_Synchronize">Synchronize</a> and <a class="xref" href="System.Security.AccessControl.MutexRights.html#System_Security_AccessControl_MutexRights_Modify">Modify</a> rights, combined by using the bitwise OR operation. Specifying the <a class="xref" href="System.Security.AccessControl.MutexRights.html#System_Security_AccessControl_MutexRights_Synchronize">Synchronize</a> flag allows a thread to wait on the mutex, and specifying the <a class="xref" href="System.Security.AccessControl.MutexRights.html#System_Security_AccessControl_MutexRights_Modify">Modify</a> flag allows a thread to call the <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex_ReleaseMutex">ReleaseMutex()</a> method. </p>
<p>This method does not request ownership of the mutex. </p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[SecurityCritical]
public static bool TryOpenExisting(string name, out Mutex result)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.String.html#System_String">String</a></td>
                    <td><em>name</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a></td>
                    <td><em>result</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_Mutex_TryOpenExisting_System_String_System_Threading_Mutex___remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If the named mutex does not exist, this method does not create it. To create the system mutex when it does not already exist, use one of the <span class="xref">System.Threading.Mutex.</span> constructors that has a <em>name</em> parameter.</p>
<p>If you are uncertain whether a named mutex exists, use this method overload instead of the <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex_OpenExisting_System_String_">OpenExisting(String)</a> method overload, which throws an exception if the mutex does not exist.</p>
<p>Multiple calls to this method that use the same value for <em>name</em> do not necessarily return the same <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> object, even though the objects that are returned represent the same named system mutex. </p>
<p>This method overload is equivalent to calling the <span class="xref">System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)</span> method overload and specifying <a class="xref" href="System.Security.AccessControl.MutexRights.html#System_Security_AccessControl_MutexRights_Synchronize">Synchronize</a> and <a class="xref" href="System.Security.AccessControl.MutexRights.html#System_Security_AccessControl_MutexRights_Modify">Modify</a> rights, combined by using the bitwise OR operation. Specifying the <a class="xref" href="System.Security.AccessControl.MutexRights.html#System_Security_AccessControl_MutexRights_Synchronize">Synchronize</a> flag allows a thread to wait on the mutex, and specifying the <a class="xref" href="System.Security.AccessControl.MutexRights.html#System_Security_AccessControl_MutexRights_Modify">Modify</a> flag allows a thread to call the <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex_ReleaseMutex">ReleaseMutex()</a> method. </p>
<p>This method does not request ownership of the mutex. </p>
</div>
              <h5 id="System_Threading_Mutex_TryOpenExisting_System_String_System_Threading_Mutex___examples">Examples</h5>
              
<p>This example shows how a local <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> object is used to synchronize access to a protected resource. Because each calling thread is blocked until it acquires ownership of the mutex, it must call the <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex_ReleaseMutex">ReleaseMutex()</a> method to release ownership of the thread. </p>System.Threading.Mutex.Class#1
              
<p>In the following example, each thread calls the <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle_WaitOne_System_Int32_">WaitOne(Int32)</a> method to acquire the mutex. If the time-out interval elapses, the method returns <strong>false</strong>, and the thread neither acquires the mutex nor gains access to the resource the mutex protects. The <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex_ReleaseMutex">ReleaseMutex()</a> method is called only by the thread that acquires the mutex. </p>System.Threading.Mutex.Class#2
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.ArgumentException.html#System_ArgumentException">ArgumentException</a></td>
                    <td><p>
<em>name</em> is an empty string.</p>
<p>-or-</p>
<p>
<em>name</em> is longer than 260 characters.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.ArgumentNullException.html#System_ArgumentNullException">ArgumentNullException</a></td>
                    <td><p>
<em>name</em> is <strong>null</strong>.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.IO.IOException.html#System_IO_IOException">IOException</a></td>
                    <td><p>A Win32 error occurred.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.UnauthorizedAccessException.html#System_UnauthorizedAccessException">UnauthorizedAccessException</a></td>
                    <td><p>The named mutex exists, but the user does not have the security access required to use it.</p>
</td>
                  </tr>
                </tbody>
              </table>
            </article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
            <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
            </nav>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="inner-footer">
          <p>© .NET Foundation</p>
          <p>
            <a href="https://www.github.com/dotnet" target="_blank"><span class="fa fa-stack fa-lg">
              <span class="fa fa-square-o fa-stack-2x"></span>
              <span class="fa fa-github fa-stack-1x"></span>
            </span></a>
            <a href="https://twitter.com/dotnet" target="_blank"><span class="fa fa-stack fa-lg">
              <span class="fa fa-square-o fa-stack-2x"></span>
              <span class="fa fa-twitter fa-stack-1x"></span>
            </span></a>
            <a href="https://www.facebook.com/dotnet" target="_blank"><span class="fa fa-stack fa-lg">
              <span class="fa fa-square-o fa-stack-2x"></span>
              <span class="fa fa-facebook fa-stack-1x"></span>
            </span></a>
      
          </p>
          </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
