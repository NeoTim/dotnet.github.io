<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Class SafeHandle
   | CoreCLR site </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Class SafeHandle
   | CoreCLR site ">
    
    <link rel="shortcut icon" href="../images/Logo_DotNet.png" type="image/x-icon">
    <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/main.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/style.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  
    ga('create', 'UA-63735192-1', 'auto');
    ga('send', 'pageview');
    </script>
  </head>  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav class="navbar navbar-inverse">
             <div class="container">
               <a href="../"><img height="50px" src="../images/Logo_DotNet.png" style="float:right;"></a>
               <div class="navbar-header ">
                 <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                   <span class="sr-only">Toggle navigation</span>
                   <span class="icon-bar"></span>
                   <span class="icon-bar"></span>
                   <span class="icon-bar"></span>
                 </button>
                 <a class="navbar-brand" href="../"><span class="dotnet">.NET Core</span></a>
               </div>
               <div id="navbar" class="collapse navbar-collapse">
               </div><!--/.nav-collapse -->
             </div>
           </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content">
              
              <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Runtime_InteropServices_SafeHandle.md&amp;value=---%0Auid%3A%20System.Runtime.InteropServices.SafeHandle%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A" class="pull-right mobile-hide"><span class="fa fa-github"></span>Improve this Doc</a>
              <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs/#L137" class="pull-right mobile-hide">View Source</a>
              <h1 id="System_Runtime_InteropServices_SafeHandle" data-uid="System.Runtime.InteropServices.SafeHandle">Class SafeHandle
              </h1>
              <div class="markdown level0 summary"><p>Represents a wrapper class for operating system handles. This class must be inherited.</p>
</div>
              <div class="markdown level0 conceptual"></div>
              <div class="inheritance">
                <h5>Inheritance</h5>
                  <div class="level0"><a class="xref" href="System.Object.html#System_Object">Object</a></div>
                  <div class="level1"><span class="xref">SafeHandle</span></div>
              </div>
              <div class="inheritedMembers">
                <h5>Inherited Members</h5>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_ToString">ToString()</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_Equals_System_Object_">Equals(Object)</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_Equals_System_Object_System_Object_">Equals(Object, Object)</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_ReferenceEquals_System_Object_System_Object_">ReferenceEquals(Object, Object)</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_GetHashCode">GetHashCode()</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_GetType">GetType()</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_MemberwiseClone">MemberwiseClone()</a>
                </div>
              </div>
              <h6><strong>Namespace</strong>:System.Runtime.InteropServices</h6>
              <h6><strong>Assembly</strong>:System.Runtime.Handles.dll</h6>
              <h5 id="System_Runtime_InteropServices_SafeHandle_syntax">Syntax</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[SecurityCritical]
public abstract class SafeHandle : CriticalFinalizerObject, IDisposable</code></pre>
              </div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_examples"><strong>Examples</strong></h5>
              <p>The following code example creates a custom safe handle for an operating system file handle, deriving from <span class="xref">SafeHandleZeroOrMinusOneIsInvalid</span>. It reads bytes from a file and displays their hexadecimal values. It also contains a fault testing harness that causes the thread to abort, but the handle value is freed.  When using an <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> to represent handles, the handle is occasionally leaked due to the asynchronous thread abort.</p>
<p>You will need a text file in the same folder as the compiled application. Assuming that you name the application "HexViewer", the command line usage is:</p>
<p>
<code>HexViewer <filename> -Fault</filename></code>
</p>
<p>Optionally specify <code>-Fault</code> to intentionally attempt to leak the handle by aborting the thread in a certain window. Use the Windows Perform.exe tool to monitor handle counts while injecting faults.</p>SafeHandle#1
              <h3 id="constructors">Constructors
              </h3>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Runtime_InteropServices_SafeHandle__ctor_System_IntPtr_System_Boolean_.md&amp;value=---%0Auid%3A%20System.Runtime.InteropServices.SafeHandle.%23ctor(System.IntPtr%2CSystem.Boolean)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs/#L161">View Source</a>
              </span>
              <h4 id="System_Runtime_InteropServices_SafeHandle__ctor_System_IntPtr_System_Boolean_" data-uid="System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)">SafeHandle(IntPtr, Boolean)</h4>
              <div class="markdown level1 summary"><p>Initializes a new instance of the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> class with the specified invalid handle value.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Runtime_InteropServices_SafeHandle__ctor_System_IntPtr_System_Boolean__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If the <em>ownsHandle</em> parameter is <strong>false</strong>, <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_ReleaseHandle">ReleaseHandle()</a> is never called; thus, it is not recommended to use this parameter value as your code may leak resources.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
protected SafeHandle(IntPtr invalidHandleValue, bool ownsHandle)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a></td>
                    <td><em>invalidHandleValue</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td><em>ownsHandle</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Runtime_InteropServices_SafeHandle__ctor_System_IntPtr_System_Boolean__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If the <em>ownsHandle</em> parameter is <strong>false</strong>, <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_ReleaseHandle">ReleaseHandle()</a> is never called; thus, it is not recommended to use this parameter value as your code may leak resources.</p>
</div>
              <h5 id="System_Runtime_InteropServices_SafeHandle__ctor_System_IntPtr_System_Boolean__examples">Examples</h5>
              <p>The following code example creates a custom safe handle for an operating system file handle, deriving from <span class="xref">SafeHandleZeroOrMinusOneIsInvalid</span>. It reads bytes from a file and displays their hexadecimal values. It also contains a fault testing harness that causes the thread to abort, but the handle value is freed.  When using an <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> to represent handles, the handle is occasionally leaked due to the asynchronous thread abort.</p>
<p>You will need a text file in the same folder as the compiled application. Assuming that you name the application "HexViewer", the command line usage is:</p>
<p>
<code>HexViewer <filename> -Fault</filename></code>
</p>
<p>Optionally specify <code>-Fault</code> to intentionally attempt to leak the handle by aborting the thread in a certain window. Use the Windows Perform.exe tool to monitor handle counts while injecting faults.</p>SafeHandle#1
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.TypeLoadException.html#System_TypeLoadException">TypeLoadException</a></td>
                    <td><p>The derived class resides in an assembly without unmanaged code access permission. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <h3 id="fields">Fields
              </h3>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Runtime_InteropServices_SafeHandle_handle.md&amp;value=---%0Auid%3A%20System.Runtime.InteropServices.SafeHandle.handle%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs/#L151">View Source</a>
              </span>
              <h4 id="System_Runtime_InteropServices_SafeHandle_handle" data-uid="System.Runtime.InteropServices.SafeHandle.handle">handle</h4>
              <div class="markdown level1 summary"><p>Specifies the handle to be wrapped.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_handle_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Do not expose the handle publicly (that is, outside of the derived class).</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">protected IntPtr handle</code></pre>
              </div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_handle_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Do not expose the handle publicly (that is, outside of the derived class).</p>
</div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_handle_examples">Examples</h5>
              <p>The following code example creates a custom safe handle for an operating system file handle, deriving from <span class="xref">SafeHandleZeroOrMinusOneIsInvalid</span>. It reads bytes from a file and displays their hexadecimal values. It also contains a fault testing harness that causes the thread to abort, but the handle value is freed.  When using an <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> to represent handles, the handle is occasionally leaked due to the asynchronous thread abort.</p>
<p>You will need a text file in the same folder as the compiled application. Assuming that you name the application "HexViewer", the command line usage is:</p>
<p>
<code>HexViewer <filename> -Fault</filename></code>
</p>
<p>Optionally specify <code>-Fault</code> to intentionally attempt to leak the handle by aborting the thread in a certain window. Use the Windows Perform.exe tool to monitor handle counts while injecting faults.</p>SafeHandle#1
              <h3 id="properties">Properties
              </h3>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Runtime_InteropServices_SafeHandle_IsClosed.md&amp;value=---%0Auid%3A%20System.Runtime.InteropServices.SafeHandle.IsClosed%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs/#L229">View Source</a>
              </span>
              <h4 id="System_Runtime_InteropServices_SafeHandle_IsClosed" data-uid="System.Runtime.InteropServices.SafeHandle.IsClosed">IsClosed</h4>
              <div class="markdown level1 summary"><p>Gets a value indicating whether the handle is closed.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_IsClosed_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p><p>The <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_IsClosed">IsClosed</a> method returns a value indicating whether the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> object&#39;s handle is no longer associated with a native resource. This differs from the definition of the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_IsInvalid">IsInvalid</a> property, which computes whether a given handle is always considered invalid. The <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_IsClosed">IsClosed</a> method returns a <strong>true</strong> value in the following cases:</p></p>
<ul><li>
<p>The <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_SetHandleAsInvalid">SetHandleAsInvalid()</a> method was called.</p>
</li><li>
<p>The <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_Dispose">Dispose()</a> method or <span class="xref">Close()</span> method was called and there are no references to the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> object on other threads.</p>
</li></ul>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public bool IsClosed
{
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    get;
}</code></pre>
              </div>
              <h5 class="propertyValue"></h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Runtime_InteropServices_SafeHandle_IsClosed_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p><p>The <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_IsClosed">IsClosed</a> method returns a value indicating whether the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> object&#39;s handle is no longer associated with a native resource. This differs from the definition of the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_IsInvalid">IsInvalid</a> property, which computes whether a given handle is always considered invalid. The <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_IsClosed">IsClosed</a> method returns a <strong>true</strong> value in the following cases:</p></p>
<ul><li>
<p>The <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_SetHandleAsInvalid">SetHandleAsInvalid()</a> method was called.</p>
</li><li>
<p>The <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_Dispose">Dispose()</a> method or <span class="xref">Close()</span> method was called and there are no references to the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> object on other threads.</p>
</li></ul>
</div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_IsClosed_examples">Examples</h5>
              <p>The following code example creates a custom safe handle for an operating system file handle, deriving from <span class="xref">SafeHandleZeroOrMinusOneIsInvalid</span>. It reads bytes from a file and displays their hexadecimal values. It also contains a fault testing harness that causes the thread to abort, but the handle value is freed.  When using an <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> to represent handles, the handle is occasionally leaked due to the asynchronous thread abort.</p>
<p>You will need a text file in the same folder as the compiled application. Assuming that you name the application "HexViewer", the command line usage is:</p>
<p>
<code>HexViewer <filename> -Fault</filename></code>
</p>
<p>Optionally specify <code>-Fault</code> to intentionally attempt to leak the handle by aborting the thread in a certain window. Use the Windows Perform.exe tool to monitor handle counts while injecting faults.</p>SafeHandle#1
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Runtime_InteropServices_SafeHandle_IsInvalid.md&amp;value=---%0Auid%3A%20System.Runtime.InteropServices.SafeHandle.IsInvalid%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs/#L234">View Source</a>
              </span>
              <h4 id="System_Runtime_InteropServices_SafeHandle_IsInvalid" data-uid="System.Runtime.InteropServices.SafeHandle.IsInvalid">IsInvalid</h4>
              <div class="markdown level1 summary"><p>When overridden in a derived class, gets a value indicating whether the handle value is invalid.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_IsInvalid_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Derived classes must implement the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_IsInvalid">IsInvalid</a> property so that the common language runtime can determine whether critical finalization is required. Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid). These classes can then be further derived for specific safe handle types.</p>
<p>Unlike the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_IsClosed">IsClosed</a> property, which reports whether the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> object has finished using the underlying handle, the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_IsInvalid">IsInvalid</a> property calculates whether the given handle value is always considered invalid. Therefore, the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_IsInvalid">IsInvalid</a> property always returns the same value for any one handle value.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">public abstract bool IsInvalid
{
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    get;
}</code></pre>
              </div>
              <h5 class="propertyValue"></h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Runtime_InteropServices_SafeHandle_IsInvalid_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Derived classes must implement the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_IsInvalid">IsInvalid</a> property so that the common language runtime can determine whether critical finalization is required. Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid). These classes can then be further derived for specific safe handle types.</p>
<p>Unlike the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_IsClosed">IsClosed</a> property, which reports whether the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> object has finished using the underlying handle, the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_IsInvalid">IsInvalid</a> property calculates whether the given handle value is always considered invalid. Therefore, the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_IsInvalid">IsInvalid</a> property always returns the same value for any one handle value.</p>
</div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_IsInvalid_examples">Examples</h5>
              
<p>The following example checks if a file was opened successfully. This code example is part of a larger example provided for the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> class.</p>SafeHandle#2
              <h3 id="methods">Methods
              </h3>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean__.md&amp;value=---%0Auid%3A%20System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean%40)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              
              <h4 id="System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean__" data-uid="System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)">DangerousAddRef(ref Boolean)</h4>
              <div class="markdown level1 summary"><p>Manually increments the reference counter on <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> instances.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean___remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>The <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean__">DangerousAddRef(ref Boolean)</a> method prevents the common language runtime from reclaiming memory used by a handle (which occurs when the runtime calls the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_ReleaseHandle">ReleaseHandle()</a> method). You can use this method to manually increment the reference count on a <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> instance. <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean__">DangerousAddRef(ref Boolean)</a> returns a Boolean value using a <strong>ref</strong> parameter (<em>success</em>) that indicates whether the reference count was incremented successfully. This allows your program logic to back out in case of failure. You should set <em>success</em> to <strong>false</strong> before calling <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean__">DangerousAddRef(ref Boolean)</a>. If <em>success</em> is <strong>true</strong>, avoid resource leaks by matching the call to <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean__">DangerousAddRef(ref Boolean)</a> with a corresponding call to <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousRelease">DangerousRelease()</a>.</p>
<p>This method is intended for advanced users and must always be used carefully. To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[SecurityCritical]
[ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
[MethodImpl(MethodImplOptions.InternalCall)]
public void DangerousAddRef(ref bool success)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td><em>success</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean___remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>The <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean__">DangerousAddRef(ref Boolean)</a> method prevents the common language runtime from reclaiming memory used by a handle (which occurs when the runtime calls the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_ReleaseHandle">ReleaseHandle()</a> method). You can use this method to manually increment the reference count on a <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> instance. <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean__">DangerousAddRef(ref Boolean)</a> returns a Boolean value using a <strong>ref</strong> parameter (<em>success</em>) that indicates whether the reference count was incremented successfully. This allows your program logic to back out in case of failure. You should set <em>success</em> to <strong>false</strong> before calling <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean__">DangerousAddRef(ref Boolean)</a>. If <em>success</em> is <strong>true</strong>, avoid resource leaks by matching the call to <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean__">DangerousAddRef(ref Boolean)</a> with a corresponding call to <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousRelease">DangerousRelease()</a>.</p>
<p>This method is intended for advanced users and must always be used carefully. To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing.</p>
</div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean___examples">Examples</h5>
              <p>The following code example creates a custom safe handle for an operating system file handle, deriving from <span class="xref">SafeHandleZeroOrMinusOneIsInvalid</span>. It reads bytes from a file and displays their hexadecimal values. It also contains a fault testing harness that causes the thread to abort, but the handle value is freed.  When using an <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> to represent handles, the handle is occasionally leaked due to the asynchronous thread abort.</p>
<p>You will need a text file in the same folder as the compiled application. Assuming that you name the application "HexViewer", the command line usage is:</p>
<p>
<code>HexViewer <filename> -Fault</filename></code>
</p>
<p>Optionally specify <code>-Fault</code> to intentionally attempt to leak the handle by aborting the thread in a certain window. Use the Windows Perform.exe tool to monitor handle counts while injecting faults.</p>SafeHandle#1
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Runtime_InteropServices_SafeHandle_DangerousGetHandle.md&amp;value=---%0Auid%3A%20System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs/#L223">View Source</a>
              </span>
              <h4 id="System_Runtime_InteropServices_SafeHandle_DangerousGetHandle" data-uid="System.Runtime.InteropServices.SafeHandle.DangerousGetHandle">DangerousGetHandle()</h4>
              <div class="markdown level1 summary"><p>Returns the value of the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_handle">handle</a> field.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_DangerousGetHandle_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>You can use this method to retrieve the actual handle value from an instance of the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> derived class. This method is needed for backwards compatibility because many properties in the .NET Framework return <strong>IntPtr</strong> handle types. <strong>IntPtr</strong> handle types are platform-specific types used to represent a pointer or a handle.</p>
<p>Using the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousGetHandle">DangerousGetHandle()</a> method can pose security risks because, if the handle has been marked as invalid with <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_SetHandleAsInvalid">SetHandleAsInvalid()</a>, <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousGetHandle">DangerousGetHandle()</a> still returns the original, potentially stale handle value. The returned handle can also be recycled at any point. At best, this means the handle might suddenly stop working. At worst, if the handle or the resource that the handle represents is exposed to untrusted code, this can lead to a recycling security attack on the reused or returned handle. For example, an untrusted caller can query data on the handle just returned and receive information for an entirely unrelated resource. See the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean__">DangerousAddRef(ref Boolean)</a> and the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousRelease">DangerousRelease()</a> methods for more information about using the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousGetHandle">DangerousGetHandle()</a> methodsafely.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
public IntPtr DangerousGetHandle()</code></pre>
              </div>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Runtime_InteropServices_SafeHandle_DangerousGetHandle_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>You can use this method to retrieve the actual handle value from an instance of the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> derived class. This method is needed for backwards compatibility because many properties in the .NET Framework return <strong>IntPtr</strong> handle types. <strong>IntPtr</strong> handle types are platform-specific types used to represent a pointer or a handle.</p>
<p>Using the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousGetHandle">DangerousGetHandle()</a> method can pose security risks because, if the handle has been marked as invalid with <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_SetHandleAsInvalid">SetHandleAsInvalid()</a>, <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousGetHandle">DangerousGetHandle()</a> still returns the original, potentially stale handle value. The returned handle can also be recycled at any point. At best, this means the handle might suddenly stop working. At worst, if the handle or the resource that the handle represents is exposed to untrusted code, this can lead to a recycling security attack on the reused or returned handle. For example, an untrusted caller can query data on the handle just returned and receive information for an entirely unrelated resource. See the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean__">DangerousAddRef(ref Boolean)</a> and the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousRelease">DangerousRelease()</a> methods for more information about using the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousGetHandle">DangerousGetHandle()</a> methodsafely.</p>
</div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_DangerousGetHandle_examples">Examples</h5>
              <p>The following code example creates a custom safe handle for an operating system file handle, deriving from <span class="xref">SafeHandleZeroOrMinusOneIsInvalid</span>. It reads bytes from a file and displays their hexadecimal values. It also contains a fault testing harness that causes the thread to abort, but the handle value is freed.  When using an <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> to represent handles, the handle is occasionally leaked due to the asynchronous thread abort.</p>
<p>You will need a text file in the same folder as the compiled application. Assuming that you name the application "HexViewer", the command line usage is:</p>
<p>
<code>HexViewer <filename> -Fault</filename></code>
</p>
<p>Optionally specify <code>-Fault</code> to intentionally attempt to leak the handle by aborting the thread in a certain window. Use the Windows Perform.exe tool to monitor handle counts while injecting faults.</p>SafeHandle#1
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Runtime_InteropServices_SafeHandle_DangerousRelease.md&amp;value=---%0Auid%3A%20System.Runtime.InteropServices.SafeHandle.DangerousRelease%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              
              <h4 id="System_Runtime_InteropServices_SafeHandle_DangerousRelease" data-uid="System.Runtime.InteropServices.SafeHandle.DangerousRelease">DangerousRelease()</h4>
              <div class="markdown level1 summary"><p>Manually decrements the reference counter on a <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> instance.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_DangerousRelease_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>The <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousRelease">DangerousRelease()</a> method is the counterpart to <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean__">DangerousAddRef(ref Boolean)</a>. You should always match a call to the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousRelease">DangerousRelease()</a> method with a successful call to <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean__">DangerousAddRef(ref Boolean)</a>.</p>
<p>This method is intended for advanced users and must always be used carefully. To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing. In the same way that unmatched <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean__">DangerousAddRef(ref Boolean)</a> calls can cause resource leaks, unmatched <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousRelease">DangerousRelease()</a> calls can cause invalid handle states to become visible to other threads. Do not expose <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean__">DangerousAddRef(ref Boolean)</a> or <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousRelease">DangerousRelease()</a> calls to untrusted code.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[SecurityCritical]
[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
[MethodImpl(MethodImplOptions.InternalCall)]
public void DangerousRelease()</code></pre>
              </div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_DangerousRelease_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>The <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousRelease">DangerousRelease()</a> method is the counterpart to <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean__">DangerousAddRef(ref Boolean)</a>. You should always match a call to the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousRelease">DangerousRelease()</a> method with a successful call to <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean__">DangerousAddRef(ref Boolean)</a>.</p>
<p>This method is intended for advanced users and must always be used carefully. To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing. In the same way that unmatched <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean__">DangerousAddRef(ref Boolean)</a> calls can cause resource leaks, unmatched <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousRelease">DangerousRelease()</a> calls can cause invalid handle states to become visible to other threads. Do not expose <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean__">DangerousAddRef(ref Boolean)</a> or <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_DangerousRelease">DangerousRelease()</a> calls to untrusted code.</p>
</div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_DangerousRelease_examples">Examples</h5>
              <p>The following code example creates a custom safe handle for an operating system file handle, deriving from <span class="xref">SafeHandleZeroOrMinusOneIsInvalid</span>. It reads bytes from a file and displays their hexadecimal values. It also contains a fault testing harness that causes the thread to abort, but the handle value is freed.  When using an <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> to represent handles, the handle is occasionally leaked due to the asynchronous thread abort.</p>
<p>You will need a text file in the same folder as the compiled application. Assuming that you name the application "HexViewer", the command line usage is:</p>
<p>
<code>HexViewer <filename> -Fault</filename></code>
</p>
<p>Optionally specify <code>-Fault</code> to intentionally attempt to leak the handle by aborting the thread in a certain window. Use the Windows Perform.exe tool to monitor handle counts while injecting faults.</p>SafeHandle#1
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Runtime_InteropServices_SafeHandle_Dispose.md&amp;value=---%0Auid%3A%20System.Runtime.InteropServices.SafeHandle.Dispose%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs/#L245">View Source</a>
              </span>
              <h4 id="System_Runtime_InteropServices_SafeHandle_Dispose" data-uid="System.Runtime.InteropServices.SafeHandle.Dispose">Dispose()</h4>
              <div class="markdown level1 summary"><p>Releases all resources used by the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> class.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_Dispose_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Calling the <span class="xref">Close()</span> or <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_Dispose">Dispose()</a> method allows the resources to be freed. This might not happen immediately if other threads are using the same instance of the safe handle, but will happen as soon as that is no longer the case. Although most classes using <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory). In this case, they can provide a finalizer that is guaranteed to run before the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> critical finalizer runs.</p>
<p>Call the <span class="xref">Close()</span> or <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_Dispose">Dispose()</a> method when you are finished using the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> object. The <span class="xref">Close()</span> method leaves the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> object in an unusable state.</p>
<p>Always call the <span class="xref">Close()</span> or <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_Dispose">Dispose()</a> method before you release your last reference to the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> object. Otherwise, the resources it is using will not be freed until the garbage collector calls the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> object&#39;s <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_Finalize">Finalize()</a> method.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[SecuritySafeCritical]
[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
public void Dispose()</code></pre>
              </div>
              <h5 class="implements">Implements</h5>
                  <div><a class="xref" href="System.IDisposable.html#System_IDisposable_Dispose">Dispose()</a></div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_Dispose_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Calling the <span class="xref">Close()</span> or <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_Dispose">Dispose()</a> method allows the resources to be freed. This might not happen immediately if other threads are using the same instance of the safe handle, but will happen as soon as that is no longer the case. Although most classes using <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory). In this case, they can provide a finalizer that is guaranteed to run before the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> critical finalizer runs.</p>
<p>Call the <span class="xref">Close()</span> or <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_Dispose">Dispose()</a> method when you are finished using the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> object. The <span class="xref">Close()</span> method leaves the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> object in an unusable state.</p>
<p>Always call the <span class="xref">Close()</span> or <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_Dispose">Dispose()</a> method before you release your last reference to the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> object. Otherwise, the resources it is using will not be freed until the garbage collector calls the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> object&#39;s <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_Finalize">Finalize()</a> method.</p>
</div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_Dispose_examples">Examples</h5>
              <p>The following code example creates a custom safe handle for an operating system file handle, deriving from <span class="xref">SafeHandleZeroOrMinusOneIsInvalid</span>. It reads bytes from a file and displays their hexadecimal values. It also contains a fault testing harness that causes the thread to abort, but the handle value is freed.  When using an <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> to represent handles, the handle is occasionally leaked due to the asynchronous thread abort.</p>
<p>You will need a text file in the same folder as the compiled application. Assuming that you name the application "HexViewer", the command line usage is:</p>
<p>
<code>HexViewer <filename> -Fault</filename></code>
</p>
<p>Optionally specify <code>-Fault</code> to intentionally attempt to leak the handle by aborting the thread in a certain window. Use the Windows Perform.exe tool to monitor handle counts while injecting faults.</p>SafeHandle#1
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Runtime_InteropServices_SafeHandle_Dispose_System_Boolean_.md&amp;value=---%0Auid%3A%20System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs/#L251">View Source</a>
              </span>
              <h4 id="System_Runtime_InteropServices_SafeHandle_Dispose_System_Boolean_" data-uid="System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)">Dispose(Boolean)</h4>
              <div class="markdown level1 summary"><p>Releases the unmanaged resources used by the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> class specifying whether to perform a normal dispose operation.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_Dispose_System_Boolean__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>You should never explicitly call the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_Dispose_System_Boolean_">Dispose(Boolean)</a> method with the <em>disposing</em> parameter set to <strong>false</strong>.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[SecurityCritical]
[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
protected virtual void Dispose(bool disposing)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td><em>disposing</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Runtime_InteropServices_SafeHandle_Dispose_System_Boolean__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>You should never explicitly call the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_Dispose_System_Boolean_">Dispose(Boolean)</a> method with the <em>disposing</em> parameter set to <strong>false</strong>.</p>
</div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_Dispose_System_Boolean__examples">Examples</h5>
              <p>The following code example creates a custom safe handle for an operating system file handle, deriving from <span class="xref">SafeHandleZeroOrMinusOneIsInvalid</span>. It reads bytes from a file and displays their hexadecimal values. It also contains a fault testing harness that causes the thread to abort, but the handle value is freed.  When using an <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> to represent handles, the handle is occasionally leaked due to the asynchronous thread abort.</p>
<p>You will need a text file in the same folder as the compiled application. Assuming that you name the application "HexViewer", the command line usage is:</p>
<p>
<code>HexViewer <filename> -Fault</filename></code>
</p>
<p>Optionally specify <code>-Fault</code> to intentionally attempt to leak the handle by aborting the thread in a certain window. Use the Windows Perform.exe tool to monitor handle counts while injecting faults.</p>SafeHandle#1
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Runtime_InteropServices_SafeHandle_Finalize.md&amp;value=---%0Auid%3A%20System.Runtime.InteropServices.SafeHandle.Finalize%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs/#L194">View Source</a>
              </span>
              <h4 id="System_Runtime_InteropServices_SafeHandle_Finalize" data-uid="System.Runtime.InteropServices.SafeHandle.Finalize">Finalize()</h4>
              <div class="markdown level1 summary"><p>Frees all resources associated with the handle.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_Finalize_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>The <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_Finalize">Finalize()</a> method is the destructor for the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> class. Application code should not call this method directly.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[SecuritySafeCritical]
protected void Finalize()</code></pre>
              </div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_Finalize_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>The <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_Finalize">Finalize()</a> method is the destructor for the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> class. Application code should not call this method directly.</p>
</div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_Finalize_examples">Examples</h5>
              <p>The following code example creates a custom safe handle for an operating system file handle, deriving from <span class="xref">SafeHandleZeroOrMinusOneIsInvalid</span>. It reads bytes from a file and displays their hexadecimal values. It also contains a fault testing harness that causes the thread to abort, but the handle value is freed.  When using an <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> to represent handles, the handle is occasionally leaked due to the asynchronous thread abort.</p>
<p>You will need a text file in the same folder as the compiled application. Assuming that you name the application "HexViewer", the command line usage is:</p>
<p>
<code>HexViewer <filename> -Fault</filename></code>
</p>
<p>Optionally specify <code>-Fault</code> to intentionally attempt to leak the handle by aborting the thread in a certain window. Use the Windows Perform.exe tool to monitor handle counts while injecting faults.</p>SafeHandle#1
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Runtime_InteropServices_SafeHandle_ReleaseHandle.md&amp;value=---%0Auid%3A%20System.Runtime.InteropServices.SafeHandle.ReleaseHandle%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs/#L282">View Source</a>
              </span>
              <h4 id="System_Runtime_InteropServices_SafeHandle_ReleaseHandle" data-uid="System.Runtime.InteropServices.SafeHandle.ReleaseHandle">ReleaseHandle()</h4>
              <div class="markdown level1 summary"><p>When overridden in a derived class, executes the code required to free the handle.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_ReleaseHandle_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>The <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_ReleaseHandle">ReleaseHandle()</a> method is guaranteed to be called only once and only if the handle is valid as defined by the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_IsInvalid">IsInvalid</a> property. Implement this method in your <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> derived classes to execute any code that is required to free the handle. Because one of the functions of <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> is to guarantee prevention of resource leaks, the code in your implementation of <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_ReleaseHandle">ReleaseHandle()</a> must never fail. The garbage collector calls <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_ReleaseHandle">ReleaseHandle()</a>after normal finalizers have been run for objects that were garbage collected at the same time. The garbage collector guarantees the resources to invoke this method and that the method will not be interrupted while it is in progress. This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph). Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_ReleaseHandle">ReleaseHandle()</a> method. In particular, apply the <span class="xref">System.Runtime.ConstrainedExecution.ReliabilityContractAttribute</span> attribute to any methods you call from <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_ReleaseHandle">ReleaseHandle()</a>. In most cases this code should be:</p>
<p>
<code>ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)</code>
</p>
<p>Additionally, for simple cleanup (for example, calling the Win32 API <strong>CloseHandle</strong> on a file handle) you can check the return value for the single platform invoke call. For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail. You must ensure that your program logic has fallback code for each of those cases.</p>
<p>If <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_ReleaseHandle">ReleaseHandle()</a> returns <strong>false</strong> for any reason, it generates a releaseHandleFailed MDA Managed Debugging Assistant.  This helps you detect cases where your attempt to release resources fails.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
protected abstract bool ReleaseHandle()</code></pre>
              </div>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Runtime_InteropServices_SafeHandle_ReleaseHandle_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>The <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_ReleaseHandle">ReleaseHandle()</a> method is guaranteed to be called only once and only if the handle is valid as defined by the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_IsInvalid">IsInvalid</a> property. Implement this method in your <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> derived classes to execute any code that is required to free the handle. Because one of the functions of <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> is to guarantee prevention of resource leaks, the code in your implementation of <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_ReleaseHandle">ReleaseHandle()</a> must never fail. The garbage collector calls <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_ReleaseHandle">ReleaseHandle()</a>after normal finalizers have been run for objects that were garbage collected at the same time. The garbage collector guarantees the resources to invoke this method and that the method will not be interrupted while it is in progress. This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph). Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_ReleaseHandle">ReleaseHandle()</a> method. In particular, apply the <span class="xref">System.Runtime.ConstrainedExecution.ReliabilityContractAttribute</span> attribute to any methods you call from <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_ReleaseHandle">ReleaseHandle()</a>. In most cases this code should be:</p>
<p>
<code>ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)</code>
</p>
<p>Additionally, for simple cleanup (for example, calling the Win32 API <strong>CloseHandle</strong> on a file handle) you can check the return value for the single platform invoke call. For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail. You must ensure that your program logic has fallback code for each of those cases.</p>
<p>If <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_ReleaseHandle">ReleaseHandle()</a> returns <strong>false</strong> for any reason, it generates a releaseHandleFailed MDA Managed Debugging Assistant.  This helps you detect cases where your attempt to release resources fails.</p>
</div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_ReleaseHandle_examples">Examples</h5>
              
<p>The following code example releases the handle and is part of a larger example provided for the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> class.</p>SafeHandle#3
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Runtime_InteropServices_SafeHandle_SetHandle_System_IntPtr_.md&amp;value=---%0Auid%3A%20System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs/#L204">View Source</a>
              </span>
              <h4 id="System_Runtime_InteropServices_SafeHandle_SetHandle_System_IntPtr_" data-uid="System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)">SetHandle(IntPtr)</h4>
              <div class="markdown level1 summary"><p>Sets the handle to the specified pre-existing handle.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_SetHandle_System_IntPtr__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Use the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_SetHandle_System_IntPtr_">SetHandle(IntPtr)</a> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling output handles in a structure.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
protected void SetHandle(IntPtr handle)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a></td>
                    <td><em>handle</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Runtime_InteropServices_SafeHandle_SetHandle_System_IntPtr__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Use the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_SetHandle_System_IntPtr_">SetHandle(IntPtr)</a> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling output handles in a structure.</p>
</div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_SetHandle_System_IntPtr__examples">Examples</h5>
              <p>The following code example creates a custom safe handle for an operating system file handle, deriving from <span class="xref">SafeHandleZeroOrMinusOneIsInvalid</span>. It reads bytes from a file and displays their hexadecimal values. It also contains a fault testing harness that causes the thread to abort, but the handle value is freed.  When using an <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> to represent handles, the handle is occasionally leaked due to the asynchronous thread abort.</p>
<p>You will need a text file in the same folder as the compiled application. Assuming that you name the application "HexViewer", the command line usage is:</p>
<p>
<code>HexViewer <filename> -Fault</filename></code>
</p>
<p>Optionally specify <code>-Fault</code> to intentionally attempt to leak the handle by aborting the thread in a certain window. Use the Windows Perform.exe tool to monitor handle counts while injecting faults.</p>SafeHandle#1
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Runtime_InteropServices_SafeHandle_SetHandleAsInvalid.md&amp;value=---%0Auid%3A%20System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              
              <h4 id="System_Runtime_InteropServices_SafeHandle_SetHandleAsInvalid" data-uid="System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid">SetHandleAsInvalid()</h4>
              <div class="markdown level1 summary"><p>Marks a handle as no longer used.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_SetHandleAsInvalid_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Call the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_SetHandleAsInvalid">SetHandleAsInvalid()</a> method only when you know that your handle no longer references a resource. Doing so does not change the value of the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_handle">handle</a> field; it only marks the handle as closed. The handle might then contain a potentially stale value. The effect of this call is that no attempt is made to free the resources.</p>
<p>As with the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_SetHandle_System_IntPtr_">SetHandle(IntPtr)</a> method, use <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_SetHandleAsInvalid">SetHandleAsInvalid()</a> only if you need to support a pre-existing handle.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[SecurityCritical]
[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
[MethodImpl(MethodImplOptions.InternalCall)]
public void SetHandleAsInvalid()</code></pre>
              </div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_SetHandleAsInvalid_remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>Call the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_SetHandleAsInvalid">SetHandleAsInvalid()</a> method only when you know that your handle no longer references a resource. Doing so does not change the value of the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_handle">handle</a> field; it only marks the handle as closed. The handle might then contain a potentially stale value. The effect of this call is that no attempt is made to free the resources.</p>
<p>As with the <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_SetHandle_System_IntPtr_">SetHandle(IntPtr)</a> method, use <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle_SetHandleAsInvalid">SetHandleAsInvalid()</a> only if you need to support a pre-existing handle.</p>
</div>
              <h5 id="System_Runtime_InteropServices_SafeHandle_SetHandleAsInvalid_examples">Examples</h5>
              <p>The following code example creates a custom safe handle for an operating system file handle, deriving from <span class="xref">SafeHandleZeroOrMinusOneIsInvalid</span>. It reads bytes from a file and displays their hexadecimal values. It also contains a fault testing harness that causes the thread to abort, but the handle value is freed.  When using an <a class="xref" href="System.IntPtr.html#System_IntPtr">IntPtr</a> to represent handles, the handle is occasionally leaked due to the asynchronous thread abort.</p>
<p>You will need a text file in the same folder as the compiled application. Assuming that you name the application "HexViewer", the command line usage is:</p>
<p>
<code>HexViewer <filename> -Fault</filename></code>
</p>
<p>Optionally specify <code>-Fault</code> to intentionally attempt to leak the handle by aborting the thread in a certain window. Use the Windows Perform.exe tool to monitor handle counts while injecting faults.</p>SafeHandle#1
            </article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
            <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
            </nav>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="inner-footer">
          <p>© .NET Foundation</p>
          <p>
            <a href="https://www.github.com/dotnet" target="_blank"><span class="fa fa-stack fa-lg">
              <span class="fa fa-square-o fa-stack-2x"></span>
              <span class="fa fa-github fa-stack-1x"></span>
            </span></a>
            <a href="https://twitter.com/dotnet" target="_blank"><span class="fa fa-stack fa-lg">
              <span class="fa fa-square-o fa-stack-2x"></span>
              <span class="fa fa-twitter fa-stack-1x"></span>
            </span></a>
            <a href="https://www.facebook.com/dotnet" target="_blank"><span class="fa fa-stack fa-lg">
              <span class="fa fa-square-o fa-stack-2x"></span>
              <span class="fa fa-facebook fa-stack-1x"></span>
            </span></a>
      
          </p>
          </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
