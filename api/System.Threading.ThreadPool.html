<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Class ThreadPool
   | CoreCLR site </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Class ThreadPool
   | CoreCLR site ">
    
    <link rel="shortcut icon" href="../images/Logo_DotNet.png" type="image/x-icon">
    <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/main.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/style.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  
    ga('create', 'UA-63735192-1', 'auto');
    ga('send', 'pageview');
    </script>
  </head>  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav class="navbar navbar-inverse">
             <div class="container">
               <a href="../"><img height="50px" src="../images/Logo_DotNet.png" style="float:right;"></a>
               <div class="navbar-header ">
                 <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                   <span class="sr-only">Toggle navigation</span>
                   <span class="icon-bar"></span>
                   <span class="icon-bar"></span>
                   <span class="icon-bar"></span>
                 </button>
                 <a class="navbar-brand" href="../"><span class="dotnet">.NET Core</span></a>
               </div>
               <div id="navbar" class="collapse navbar-collapse">
               </div><!--/.nav-collapse -->
             </div>
           </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content">
              
              <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ThreadPool.md&amp;value=---%0Auid%3A%20System.Threading.ThreadPool%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A" class="pull-right mobile-hide"><span class="fa fa-github"></span>Improve this Doc</a>
              <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/ThreadPool.cs/#L1394" class="pull-right mobile-hide">View Source</a>
              <h1 id="System_Threading_ThreadPool" data-uid="System.Threading.ThreadPool">Class ThreadPool
              </h1>
              <div class="markdown level0 summary"><p>Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</p>
</div>
              <div class="markdown level0 conceptual"></div>
              <div class="inheritance">
                <h5>Inheritance</h5>
                  <div class="level0"><a class="xref" href="System.Object.html#System_Object">Object</a></div>
                  <div class="level1"><span class="xref">ThreadPool</span></div>
              </div>
              <div class="inheritedMembers">
                <h5>Inherited Members</h5>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_ToString">ToString()</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_Equals_System_Object_">Equals(Object)</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_Equals_System_Object_System_Object_">Equals(Object, Object)</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_ReferenceEquals_System_Object_System_Object_">ReferenceEquals(Object, Object)</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_GetHashCode">GetHashCode()</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_GetType">GetType()</a>
                </div>
                <div>
                  <a class="xref" href="System.Object.html#System_Object_MemberwiseClone">MemberwiseClone()</a>
                </div>
              </div>
              <h6><strong>Namespace</strong>:System.Threading</h6>
              <h6><strong>Assembly</strong>:System.Threading.ThreadPool.dll</h6>
              <h5 id="System_Threading_ThreadPool_syntax">Syntax</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[HostProtection(Synchronization = true, ExternalThreading = true)]
public class ThreadPool</code></pre>
              </div>
              <h5 id="System_Threading_ThreadPool_examples"><strong>Examples</strong></h5>
              
<p>In the following example, the main application thread  queues a method named <code>ThreadProc</code> to execute on a thread pool thread, sleeps for one second, and then exits. The <code>ThreadProc</code> method simply displays a message.</p>System.Threading.ThreadPool QueueUserWorkItem0#1<p>If you comment out the call to the <a class="xref" href="System.Threading.Thread.html#System_Threading_Thread_Sleep_System_Int32_">Sleep(Int32)</a> method, the main thread exits before
method runs on the thread pool thread.  The thread pool uses background
threads, which do not keep the application running if all foreground threads have terminated.  (This
is a simple example of a race condition.)</p>
              <h3 id="methods">Methods
              </h3>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ThreadPool_BindHandle_System_Runtime_InteropServices_SafeHandle_.md&amp;value=---%0Auid%3A%20System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/ThreadPool.cs/#L1922">View Source</a>
              </span>
              <h4 id="System_Threading_ThreadPool_BindHandle_System_Runtime_InteropServices_SafeHandle_" data-uid="System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)">BindHandle(SafeHandle)</h4>
              <div class="markdown level1 summary"><p>Binds an operating system handle to the <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool">ThreadPool</a>.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ThreadPool_BindHandle_System_Runtime_InteropServices_SafeHandle__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>The <em>osHandle</em> parameter should be a <a class="xref" href="Microsoft.Win32.SafeHandles.SafeFileHandle.html#Microsoft_Win32_SafeHandles_SafeFileHandle">SafeFileHandle</a>, which derives from the abstract <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> class. </p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[SecurityCritical]
[SecurityPermission(SecurityAction.Demand, Flags = SecurityPermissionFlag.UnmanagedCode)]
public static bool BindHandle(SafeHandle osHandle)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a></td>
                    <td><em>osHandle</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ThreadPool_BindHandle_System_Runtime_InteropServices_SafeHandle__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>The <em>osHandle</em> parameter should be a <a class="xref" href="Microsoft.Win32.SafeHandles.SafeFileHandle.html#Microsoft_Win32_SafeHandles_SafeFileHandle">SafeFileHandle</a>, which derives from the abstract <a class="xref" href="System.Runtime.InteropServices.SafeHandle.html#System_Runtime_InteropServices_SafeHandle">SafeHandle</a> class. </p>
</div>
              <h5 id="System_Threading_ThreadPool_BindHandle_System_Runtime_InteropServices_SafeHandle__examples">Examples</h5>
              
<p>In the following example, the main application thread  queues a method named <code>ThreadProc</code> to execute on a thread pool thread, sleeps for one second, and then exits. The <code>ThreadProc</code> method simply displays a message.</p>System.Threading.ThreadPool QueueUserWorkItem0#1<p>If you comment out the call to the <a class="xref" href="System.Threading.Thread.html#System_Threading_Thread_Sleep_System_Int32_">Sleep(Int32)</a> method, the main thread exits before
method runs on the thread pool thread.  The thread pool uses background
threads, which do not keep the application running if all foreground threads have terminated.  (This
is a simple example of a race condition.)</p>
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.ArgumentNullException.html#System_ArgumentNullException">ArgumentNullException</a></td>
                    <td><p>
<em>osHandle</em> is <strong>null</strong>. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback_.md&amp;value=---%0Auid%3A%20System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/ThreadPool.cs/#L1633">View Source</a>
              </span>
              <h4 id="System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback_" data-uid="System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">QueueUserWorkItem(WaitCallback)</h4>
              <div class="markdown level1 summary"><p>Queues a method for execution. The method executes when a thread pool thread becomes available.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback_System_Object_">QueueUserWorkItem(WaitCallback, Object)</a> overload that accepts an object containing the necessary data.</p>
<p>Visual Basic users can omit the <a class="xref" href="System.Threading.WaitCallback.html#System_Threading_WaitCallback">WaitCallback</a> constructor, and simply use the <strong>AddressOf</strong> operator when passing the callback method to <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback_System_Object_">QueueUserWorkItem(WaitCallback, Object)</a>. Visual Basic automatically calls the correct delegate constructor.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[SecuritySafeCritical]
[MethodImpl(MethodImplOptions.NoInlining)]
public static bool QueueUserWorkItem(WaitCallback callBack)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.WaitCallback.html#System_Threading_WaitCallback">WaitCallback</a></td>
                    <td><em>callBack</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback_System_Object_">QueueUserWorkItem(WaitCallback, Object)</a> overload that accepts an object containing the necessary data.</p>
<p>Visual Basic users can omit the <a class="xref" href="System.Threading.WaitCallback.html#System_Threading_WaitCallback">WaitCallback</a> constructor, and simply use the <strong>AddressOf</strong> operator when passing the callback method to <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback_System_Object_">QueueUserWorkItem(WaitCallback, Object)</a>. Visual Basic automatically calls the correct delegate constructor.</p>
</div>
              <h5 id="System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback__examples">Examples</h5>
              <p>The following example uses the <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback_">QueueUserWorkItem(WaitCallback)</a> method overload to queue a task, which is represented by the <code>ThreadProc</code> method, to execute when a thread becomes available. No task information is supplied with this overload. Therefore, the information that is available to the <code>ThreadProc</code> method is limited to the object the method belongs to.</p>System.Threading.ThreadPool QueueUserWorkItem0#1
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.ArgumentNullException.html#System_ArgumentNullException">ArgumentNullException</a></td>
                    <td><p>
<em>callBack</em> is <strong>null</strong>.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.NotSupportedException.html#System_NotSupportedException">NotSupportedException</a></td>
                    <td><p>The common language runtime (CLR) is hosted, and the host does not support this action.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback_System_Object_.md&amp;value=---%0Auid%3A%20System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback%2CSystem.Object)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/ThreadPool.cs/#L1622">View Source</a>
              </span>
              <h4 id="System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback_System_Object_" data-uid="System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)">QueueUserWorkItem(WaitCallback, Object)</h4>
              <div class="markdown level1 summary"><p>Queues a method for execution, and specifies an object containing data to be used by the method. The method executes when a thread pool thread becomes available.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback_System_Object__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If the callback method requires complex data, you can define a class to contain the data.</p>
<p>Visual Basic users can omit the <a class="xref" href="System.Threading.WaitCallback.html#System_Threading_WaitCallback">WaitCallback</a> constructor, and simply use the <strong>AddressOf</strong> operator when passing the callback method to <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback_System_Object_">QueueUserWorkItem(WaitCallback, Object)</a>. Visual Basic automatically calls the correct delegate constructor.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[SecuritySafeCritical]
[MethodImpl(MethodImplOptions.NoInlining)]
public static bool QueueUserWorkItem(WaitCallback callBack, object state)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.WaitCallback.html#System_Threading_WaitCallback">WaitCallback</a></td>
                    <td><em>callBack</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Object.html#System_Object">Object</a></td>
                    <td><em>state</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback_System_Object__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>If the callback method requires complex data, you can define a class to contain the data.</p>
<p>Visual Basic users can omit the <a class="xref" href="System.Threading.WaitCallback.html#System_Threading_WaitCallback">WaitCallback</a> constructor, and simply use the <strong>AddressOf</strong> operator when passing the callback method to <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback_System_Object_">QueueUserWorkItem(WaitCallback, Object)</a>. Visual Basic automatically calls the correct delegate constructor.</p>
</div>
              <h5 id="System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback_System_Object__examples">Examples</h5>
              <p>The following example shows how to create an object that contains task information. It also demonstrates how to pass that object to a task that is queued for execution by the thread pool.</p>System.Threading.ThreadPool QueueUserWorkItem1#1
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.NotSupportedException.html#System_NotSupportedException">NotSupportedException</a></td>
                    <td><p>The common language runtime (CLR) is hosted, and the host does not support this action.</p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.ArgumentNullException.html#System_ArgumentNullException">ArgumentNullException</a></td>
                    <td><p>
<em>callBack</em> is <strong>null</strong>.</p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int32_System_Boolean_.md&amp;value=---%0Auid%3A%20System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle%2CSystem.Threading.WaitOrTimerCallback%2CSystem.Object%2CSystem.Int32%2CSystem.Boolean)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/ThreadPool.cs/#L1516">View Source</a>
              </span>
              <h4 id="System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int32_System_Boolean_" data-uid="System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int32, Boolean)</h4>
              <div class="markdown level1 summary"><p>Registers a delegate to wait for a <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle">WaitHandle</a>, specifying a 32-bit signed integer for the time-out in milliseconds.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int32_System_Boolean__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>When you are finished using the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle">RegisteredWaitHandle</a> that is returned by this method, call its <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method to release references to the wait handle. We recommend that you always call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method, even if you specify <strong>true</strong> for <em>executeOnlyOnce</em>. Garbage collection works more efficiently if you call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method instead of depending on the registered wait handle&#39;s finalizer.</p>
<p>The <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int32_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int32, Boolean)</a> method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs: </p>
<ul><li>
<p>The specified object is in the signaled state.</p>
</li><li>
<p>The time-out interval elapses.</p>
</li></ul>
<p>The <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int32_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int32, Boolean)</a> method checks the current state of the specified object&#39;s <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle">WaitHandle</a>. If the object&#39;s state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object&#39;s state becomes signaled or the time-out interval elapses. If the <em>timeOutInterval</em> parameter is not 0 (zero) and the <em>executeOnlyOnce</em> parameter is <strong>false</strong>, the timer is reset every time the event is signaled or the time-out interval elapses.</p>
<p>Using a <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> for <em>waitObject</em> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <strong>WT_EXECUTEDEFAULT</strong> flag, so each callback is dispatched on a separate thread pool thread. Instead of a <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a>, use a <a class="xref" href="System.Threading.Semaphore.html#System_Threading_Semaphore">Semaphore</a> with a maximum count of 1.</p>
<p>To cancel the wait operation, call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method.</p>
<p>The wait thread uses the Win32 WaitForMultipleObjects function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int32_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int32, Boolean)</a>, you must duplicate the handle using the Win32 DuplicateHandle function. Note that you should not pulse an event object passed to <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int32_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int32, Boolean)</a>, because the wait thread might not detect that the event is signaled before it is reset.</p>
<p>Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[SecuritySafeCritical]
[MethodImpl(MethodImplOptions.NoInlining)]
public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle">WaitHandle</a></td>
                    <td><em>waitObject</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Threading.WaitOrTimerCallback.html#System_Threading_WaitOrTimerCallback">WaitOrTimerCallback</a></td>
                    <td><em>callBack</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Object.html#System_Object">Object</a></td>
                    <td><em>state</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Int32.html#System_Int32">Int32</a></td>
                    <td><em>millisecondsTimeOutInterval</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td><em>executeOnlyOnce</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle">RegisteredWaitHandle</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int32_System_Boolean__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>When you are finished using the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle">RegisteredWaitHandle</a> that is returned by this method, call its <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method to release references to the wait handle. We recommend that you always call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method, even if you specify <strong>true</strong> for <em>executeOnlyOnce</em>. Garbage collection works more efficiently if you call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method instead of depending on the registered wait handle&#39;s finalizer.</p>
<p>The <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int32_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int32, Boolean)</a> method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs: </p>
<ul><li>
<p>The specified object is in the signaled state.</p>
</li><li>
<p>The time-out interval elapses.</p>
</li></ul>
<p>The <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int32_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int32, Boolean)</a> method checks the current state of the specified object&#39;s <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle">WaitHandle</a>. If the object&#39;s state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object&#39;s state becomes signaled or the time-out interval elapses. If the <em>timeOutInterval</em> parameter is not 0 (zero) and the <em>executeOnlyOnce</em> parameter is <strong>false</strong>, the timer is reset every time the event is signaled or the time-out interval elapses.</p>
<p>Using a <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> for <em>waitObject</em> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <strong>WT_EXECUTEDEFAULT</strong> flag, so each callback is dispatched on a separate thread pool thread. Instead of a <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a>, use a <a class="xref" href="System.Threading.Semaphore.html#System_Threading_Semaphore">Semaphore</a> with a maximum count of 1.</p>
<p>To cancel the wait operation, call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method.</p>
<p>The wait thread uses the Win32 WaitForMultipleObjects function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int32_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int32, Boolean)</a>, you must duplicate the handle using the Win32 DuplicateHandle function. Note that you should not pulse an event object passed to <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int32_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int32, Boolean)</a>, because the wait thread might not detect that the event is signaled before it is reset.</p>
<p>Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.</p>
</div>
              <h5 id="System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int32_System_Boolean__examples">Examples</h5>
              
<p>In the following example, the main application thread  queues a method named <code>ThreadProc</code> to execute on a thread pool thread, sleeps for one second, and then exits. The <code>ThreadProc</code> method simply displays a message.</p>System.Threading.ThreadPool QueueUserWorkItem0#1<p>If you comment out the call to the <a class="xref" href="System.Threading.Thread.html#System_Threading_Thread_Sleep_System_Int32_">Sleep(Int32)</a> method, the main thread exits before
method runs on the thread pool thread.  The thread pool uses background
threads, which do not keep the application running if all foreground threads have terminated.  (This
is a simple example of a race condition.)</p>
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.ArgumentOutOfRangeException.html#System_ArgumentOutOfRangeException">ArgumentOutOfRangeException</a></td>
                    <td><p>The <em>millisecondsTimeOutInterval</em> parameter is less than -1. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean_.md&amp;value=---%0Auid%3A%20System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle%2CSystem.Threading.WaitOrTimerCallback%2CSystem.Object%2CSystem.Int64%2CSystem.Boolean)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/ThreadPool.cs/#L1550">View Source</a>
              </span>
              <h4 id="System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean_" data-uid="System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int64, Boolean)</h4>
              <div class="markdown level1 summary"><p>Registers a delegate to wait for a <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle">WaitHandle</a>, specifying a 64-bit signed integer for the time-out in milliseconds.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>When you are finished using the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle">RegisteredWaitHandle</a> that is returned by this method, call its <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method to release references to the wait handle. We recommend that you always call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method, even if you specify <strong>true</strong> for <em>executeOnlyOnce</em>. Garbage collection works more efficiently if you call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method instead of depending on the registered wait handle&#39;s finalizer.</p>
<p>The <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int64, Boolean)</a> method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs: </p>
<ul><li>
<p>The specified object is in the signaled state.</p>
</li><li>
<p>The time-out interval elapses.</p>
</li></ul>
<p>The <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int64, Boolean)</a> method checks the current state of the specified object&#39;s <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle">WaitHandle</a>. If the object&#39;s state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object&#39;s state becomes signaled or the time-out interval elapses. If the <em>timeOutInterval</em> parameter is not 0 (zero) and the <em>executeOnlyOnce</em> parameter is <strong>false</strong>, the timer is reset every time the event is signaled or the time-out interval elapses.</p>
<p>Using a <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> for <em>waitObject</em> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <strong>WT_EXECUTEDEFAULT</strong> flag, so each callback is dispatched on a separate thread pool thread. Instead of a <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a>, use a <a class="xref" href="System.Threading.Semaphore.html#System_Threading_Semaphore">Semaphore</a> with a maximum count of 1.</p>
<p>To cancel the wait operation, call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method.</p>
<p>The wait thread uses the Win32 WaitForMultipleObjects function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int64, Boolean)</a>, you must duplicate the handle using the Win32 DuplicateHandle function. Note that you should not pulse an event object passed to <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int64, Boolean)</a>, because the wait thread might not detect that the event is signaled before it is reset.</p>
<p>Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[SecuritySafeCritical]
[MethodImpl(MethodImplOptions.NoInlining)]
public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle">WaitHandle</a></td>
                    <td><em>waitObject</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Threading.WaitOrTimerCallback.html#System_Threading_WaitOrTimerCallback">WaitOrTimerCallback</a></td>
                    <td><em>callBack</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Object.html#System_Object">Object</a></td>
                    <td><em>state</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Int64.html#System_Int64">Int64</a></td>
                    <td><em>millisecondsTimeOutInterval</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td><em>executeOnlyOnce</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle">RegisteredWaitHandle</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>When you are finished using the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle">RegisteredWaitHandle</a> that is returned by this method, call its <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method to release references to the wait handle. We recommend that you always call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method, even if you specify <strong>true</strong> for <em>executeOnlyOnce</em>. Garbage collection works more efficiently if you call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method instead of depending on the registered wait handle&#39;s finalizer.</p>
<p>The <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int64, Boolean)</a> method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs: </p>
<ul><li>
<p>The specified object is in the signaled state.</p>
</li><li>
<p>The time-out interval elapses.</p>
</li></ul>
<p>The <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int64, Boolean)</a> method checks the current state of the specified object&#39;s <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle">WaitHandle</a>. If the object&#39;s state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object&#39;s state becomes signaled or the time-out interval elapses. If the <em>timeOutInterval</em> parameter is not 0 (zero) and the <em>executeOnlyOnce</em> parameter is <strong>false</strong>, the timer is reset every time the event is signaled or the time-out interval elapses.</p>
<p>Using a <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> for <em>waitObject</em> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <strong>WT_EXECUTEDEFAULT</strong> flag, so each callback is dispatched on a separate thread pool thread. Instead of a <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a>, use a <a class="xref" href="System.Threading.Semaphore.html#System_Threading_Semaphore">Semaphore</a> with a maximum count of 1.</p>
<p>To cancel the wait operation, call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method.</p>
<p>The wait thread uses the Win32 WaitForMultipleObjects function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int64, Boolean)</a>, you must duplicate the handle using the Win32 DuplicateHandle function. Note that you should not pulse an event object passed to <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int64, Boolean)</a>, because the wait thread might not detect that the event is signaled before it is reset.</p>
<p>Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.</p>
</div>
              <h5 id="System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean__examples">Examples</h5>
              
<p>In the following example, the main application thread  queues a method named <code>ThreadProc</code> to execute on a thread pool thread, sleeps for one second, and then exits. The <code>ThreadProc</code> method simply displays a message.</p>System.Threading.ThreadPool QueueUserWorkItem0#1<p>If you comment out the call to the <a class="xref" href="System.Threading.Thread.html#System_Threading_Thread_Sleep_System_Int32_">Sleep(Int32)</a> method, the main thread exits before
method runs on the thread pool thread.  The thread pool uses background
threads, which do not keep the application running if all foreground threads have terminated.  (This
is a simple example of a race condition.)</p>
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.ArgumentOutOfRangeException.html#System_ArgumentOutOfRangeException">ArgumentOutOfRangeException</a></td>
                    <td><p>The <em>millisecondsTimeOutInterval</em> parameter is less than -1. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_TimeSpan_System_Boolean_.md&amp;value=---%0Auid%3A%20System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle%2CSystem.Threading.WaitOrTimerCallback%2CSystem.Object%2CSystem.TimeSpan%2CSystem.Boolean)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/ThreadPool.cs/#L1584">View Source</a>
              </span>
              <h4 id="System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_TimeSpan_System_Boolean_" data-uid="System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, TimeSpan, Boolean)</h4>
              <div class="markdown level1 summary"><p>Registers a delegate to wait for a <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle">WaitHandle</a>, specifying a <a class="xref" href="System.TimeSpan.html#System_TimeSpan">TimeSpan</a> value for the time-out.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_TimeSpan_System_Boolean__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>When you are finished using the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle">RegisteredWaitHandle</a> that is returned by this method, call its <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method to release references to the wait handle. We recommend that you always call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method, even if you specify <strong>true</strong> for <em>executeOnlyOnce</em>. Garbage collection works more efficiently if you call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method instead of depending on the registered wait handle&#39;s finalizer.</p>
<p>The <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_TimeSpan_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, TimeSpan, Boolean)</a> method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs: </p>
<ul><li>
<p>The specified object is in the signaled state.</p>
</li><li>
<p>The time-out interval elapses.</p>
</li></ul>
<p>The <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_TimeSpan_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, TimeSpan, Boolean)</a> method checks the current state of the specified object&#39;s <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle">WaitHandle</a>. If the object&#39;s state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object&#39;s state becomes signaled or the time-out interval elapses. If the <em>timeOutInterval</em> parameter is not 0 (zero) and the <em>executeOnlyOnce</em> parameter is <strong>false</strong>, the timer is reset every time the event is signaled or the time-out interval elapses.</p>
<p>Using a <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> for <em>waitObject</em> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <strong>WT_EXECUTEDEFAULT</strong> flag, so each callback is dispatched on a separate thread pool thread. Instead of a <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a>, use a <a class="xref" href="System.Threading.Semaphore.html#System_Threading_Semaphore">Semaphore</a> with a maximum count of 1.</p>
<p>To cancel the wait operation, call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method.</p>
<p>The wait thread uses the Win32 WaitForMultipleObjects function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_TimeSpan_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, TimeSpan, Boolean)</a>, you must duplicate the handle using the Win32 DuplicateHandle function. Note that you should not pulse an event object passed to <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_TimeSpan_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, TimeSpan, Boolean)</a>, because the wait thread might not detect that the event is signaled before it is reset.</p>
<p>Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[SecuritySafeCritical]
[MethodImpl(MethodImplOptions.NoInlining)]
public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle">WaitHandle</a></td>
                    <td><em>waitObject</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Threading.WaitOrTimerCallback.html#System_Threading_WaitOrTimerCallback">WaitOrTimerCallback</a></td>
                    <td><em>callBack</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Object.html#System_Object">Object</a></td>
                    <td><em>state</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.TimeSpan.html#System_TimeSpan">TimeSpan</a></td>
                    <td><em>timeout</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td><em>executeOnlyOnce</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle">RegisteredWaitHandle</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_TimeSpan_System_Boolean__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>When you are finished using the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle">RegisteredWaitHandle</a> that is returned by this method, call its <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method to release references to the wait handle. We recommend that you always call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method, even if you specify <strong>true</strong> for <em>executeOnlyOnce</em>. Garbage collection works more efficiently if you call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method instead of depending on the registered wait handle&#39;s finalizer.</p>
<p>The <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_TimeSpan_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, TimeSpan, Boolean)</a> method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs: </p>
<ul><li>
<p>The specified object is in the signaled state.</p>
</li><li>
<p>The time-out interval elapses.</p>
</li></ul>
<p>The <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_TimeSpan_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, TimeSpan, Boolean)</a> method checks the current state of the specified object&#39;s <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle">WaitHandle</a>. If the object&#39;s state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object&#39;s state becomes signaled or the time-out interval elapses. If the <em>timeOutInterval</em> parameter is not 0 (zero) and the <em>executeOnlyOnce</em> parameter is <strong>false</strong>, the timer is reset every time the event is signaled or the time-out interval elapses.</p>
<p>Using a <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> for <em>waitObject</em> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <strong>WT_EXECUTEDEFAULT</strong> flag, so each callback is dispatched on a separate thread pool thread. Instead of a <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a>, use a <a class="xref" href="System.Threading.Semaphore.html#System_Threading_Semaphore">Semaphore</a> with a maximum count of 1.</p>
<p>To cancel the wait operation, call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method.</p>
<p>The wait thread uses the Win32 WaitForMultipleObjects function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_TimeSpan_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, TimeSpan, Boolean)</a>, you must duplicate the handle using the Win32 DuplicateHandle function. Note that you should not pulse an event object passed to <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_TimeSpan_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, TimeSpan, Boolean)</a>, because the wait thread might not detect that the event is signaled before it is reset.</p>
<p>Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.</p>
</div>
              <h5 id="System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_TimeSpan_System_Boolean__examples">Examples</h5>
              
<p>In the following example, the main application thread  queues a method named <code>ThreadProc</code> to execute on a thread pool thread, sleeps for one second, and then exits. The <code>ThreadProc</code> method simply displays a message.</p>System.Threading.ThreadPool QueueUserWorkItem0#1<p>If you comment out the call to the <a class="xref" href="System.Threading.Thread.html#System_Threading_Thread_Sleep_System_Int32_">Sleep(Int32)</a> method, the main thread exits before
method runs on the thread pool thread.  The thread pool uses background
threads, which do not keep the application running if all foreground threads have terminated.  (This
is a simple example of a race condition.)</p>
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.ArgumentOutOfRangeException.html#System_ArgumentOutOfRangeException">ArgumentOutOfRangeException</a></td>
                    <td><p>The <em>timeout</em> parameter is less than -1. </p>
</td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.NotSupportedException.html#System_NotSupportedException">NotSupportedException</a></td>
                    <td><p>The <em>timeout</em> parameter is greater than <a class="xref" href="System.Int32.html#System_Int32_MaxValue">MaxValue</a>. </p>
</td>
                  </tr>
                </tbody>
              </table>
              <span class="small pull-right mobile-hide">
                <span class="divider">|</span>
                <a href="https://github.com/dotnet/core-docs/new/master/apispec/new?filename=System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_UInt32_System_Boolean_.md&amp;value=---%0Auid%3A%20System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle%2CSystem.Threading.WaitOrTimerCallback%2CSystem.Object%2CSystem.UInt32%2CSystem.Boolean)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
              </span>
              <span class="small pull-right mobile-hide">
                <a href="https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Threading/ThreadPool.cs/#L1442">View Source</a>
              </span>
              <h4 id="System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_UInt32_System_Boolean_" data-uid="System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, UInt32, Boolean)</h4>
              <div class="markdown level1 summary"><p>Registers a delegate to wait for a <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle">WaitHandle</a>, specifying a 32-bit unsigned integer for the time-out in milliseconds.</p>
</div>
              <div class="markdown level1 conceptual"></div>
              <h5 id="System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_UInt32_System_Boolean__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>When you are finished using the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle">RegisteredWaitHandle</a> that is returned by this method, call its <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method to release references to the wait handle. We recommend that you always call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method, even if you specify <strong>true</strong> for <em>executeOnlyOnce</em>. Garbage collection works more efficiently if you call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method instead of depending on the registered wait handle&#39;s finalizer.</p>
<p>The <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int64, Boolean)</a> method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs: </p>
<ul><li>
<p>The specified object is in the signaled state.</p>
</li><li>
<p>The time-out interval elapses.</p>
</li></ul>
<p>The <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int64, Boolean)</a>method checks the current state of the specified object&#39;s <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle">WaitHandle</a>. If the object&#39;s state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object&#39;s state becomes signaled or the time-out interval elapses. If the <em>timeOutInterval</em> parameter is not 0 (zero) and the <em>executeOnlyOnce</em> parameter is <strong>false</strong>, the timer is reset every time the event is signaled or the time-out interval elapses.</p>
<p>Using a <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> for <em>waitObject</em> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <strong>WT_EXECUTEDEFAULT</strong> flag, so each callback is dispatched on a separate thread pool thread. Instead of a <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a>, use a <a class="xref" href="System.Threading.Semaphore.html#System_Threading_Semaphore">Semaphore</a> with a maximum count of 1.</p>
<p>To cancel the wait operation, call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method.</p>
<p>The wait thread uses the Win32 WaitForMultipleObjects function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int64, Boolean)</a>, you must duplicate the handle using the Win32 DuplicateHandle function. Note that you should not pulse an event object passed to <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int64, Boolean)</a>, because the wait thread might not detect that the event is signaled before it is reset.</p>
<p>Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.</p>
</div>
              <h5 class="decalaration">Declaration</h5>
              <div class="codewrapper">
                <pre><code class="lang-csharp hljs">[SecuritySafeCritical]
[CLSCompliant(false)]
[MethodImpl(MethodImplOptions.NoInlining)]
public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce)</code></pre>
              </div>
              <h5 class="parameters">Parameters</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle">WaitHandle</a></td>
                    <td><em>waitObject</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Threading.WaitOrTimerCallback.html#System_Threading_WaitOrTimerCallback">WaitOrTimerCallback</a></td>
                    <td><em>callBack</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Object.html#System_Object">Object</a></td>
                    <td><em>state</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.UInt32.html#System_UInt32">UInt32</a></td>
                    <td><em>millisecondsTimeOutInterval</em></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a class="xref" href="System.Boolean.html#System_Boolean">Boolean</a></td>
                    <td><em>executeOnlyOnce</em></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 class="returns">Returns</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle">RegisteredWaitHandle</a></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h5 id="System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_UInt32_System_Boolean__remarks">Remarks</h5>
              <div class="markdown level1 remarks"><p>When you are finished using the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle">RegisteredWaitHandle</a> that is returned by this method, call its <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method to release references to the wait handle. We recommend that you always call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method, even if you specify <strong>true</strong> for <em>executeOnlyOnce</em>. Garbage collection works more efficiently if you call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method instead of depending on the registered wait handle&#39;s finalizer.</p>
<p>The <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int64, Boolean)</a> method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs: </p>
<ul><li>
<p>The specified object is in the signaled state.</p>
</li><li>
<p>The time-out interval elapses.</p>
</li></ul>
<p>The <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int64, Boolean)</a>method checks the current state of the specified object&#39;s <a class="xref" href="System.Threading.WaitHandle.html#System_Threading_WaitHandle">WaitHandle</a>. If the object&#39;s state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object&#39;s state becomes signaled or the time-out interval elapses. If the <em>timeOutInterval</em> parameter is not 0 (zero) and the <em>executeOnlyOnce</em> parameter is <strong>false</strong>, the timer is reset every time the event is signaled or the time-out interval elapses.</p>
<p>Using a <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a> for <em>waitObject</em> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <strong>WT_EXECUTEDEFAULT</strong> flag, so each callback is dispatched on a separate thread pool thread. Instead of a <a class="xref" href="System.Threading.Mutex.html#System_Threading_Mutex">Mutex</a>, use a <a class="xref" href="System.Threading.Semaphore.html#System_Threading_Semaphore">Semaphore</a> with a maximum count of 1.</p>
<p>To cancel the wait operation, call the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle_Unregister_System_Threading_WaitHandle_">Unregister(WaitHandle)</a> method.</p>
<p>The wait thread uses the Win32 WaitForMultipleObjects function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int64, Boolean)</a>, you must duplicate the handle using the Win32 DuplicateHandle function. Note that you should not pulse an event object passed to <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, Int64, Boolean)</a>, because the wait thread might not detect that the event is signaled before it is reset.</p>
<p>Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.</p>
</div>
              <h5 id="System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_UInt32_System_Boolean__examples">Examples</h5>
              <p>The following example shows how to use the <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_UInt32_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, UInt32, Boolean)</a> method to execute a specified callback method when a specified wait handle is signaled. In this example, the callback method is <code>WaitProc</code>, and the wait handle is an <a class="xref" href="System.Threading.AutoResetEvent.html#System_Threading_AutoResetEvent">AutoResetEvent</a>.</p>
<p>The example defines a <code>TaskInfo</code> class to hold the information that is passed to the callback when it executes. The example creates a <code>TaskInfo</code> object and assigns it some string data. The <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle">RegisteredWaitHandle</a> that is returned by the <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_UInt32_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, UInt32, Boolean)</a> method is assigned to the <code>Handle</code> field of the <code>TaskInfo</code> object so that the callback method has access to the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle">RegisteredWaitHandle</a>. </p>
<p>In addition to specifying <code>TaskInfo</code> as the object to pass to the callback method, the call to the <a class="xref" href="System.Threading.ThreadPool.html#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_UInt32_System_Boolean_">RegisterWaitForSingleObject(WaitHandle, WaitOrTimerCallback, Object, UInt32, Boolean)</a> method specifies the <a class="xref" href="System.Threading.AutoResetEvent.html#System_Threading_AutoResetEvent">AutoResetEvent</a> that the task will wait for, a <a class="xref" href="System.Threading.WaitOrTimerCallback.html#System_Threading_WaitOrTimerCallback">WaitOrTimerCallback</a> delegate that represents the <code>WaitProc</code> callback method, a one second time-out interval, and multiple callbacks. </p>
<p>When the main thread signals the <a class="xref" href="System.Threading.AutoResetEvent.html#System_Threading_AutoResetEvent">AutoResetEvent</a> by calling its <a class="xref" href="System.Threading.EventWaitHandle.html#System_Threading_EventWaitHandle_Set">Set()</a> method, the <a class="xref" href="System.Threading.WaitOrTimerCallback.html#System_Threading_WaitOrTimerCallback">WaitOrTimerCallback</a> delegate is invoked. The <code>WaitProc</code> method tests <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle">RegisteredWaitHandle</a> to determine whether a time-out occurred. If the callback was invoked because the wait handle was signaled, the <code>WaitProc</code> method unregisters the <a class="xref" href="System.Threading.RegisteredWaitHandle.html#System_Threading_RegisteredWaitHandle">RegisteredWaitHandle</a>, stopping additional callbacks. In the case of a time-out, the task continues to wait. The <code>WaitProc</code> method ends by printing a message to the console.</p>System.Threading.ThreadPool RegisterWaitForSingleObject0#1
              <h5 class="exceptions">Exceptions</h5>
              <table class="table table-bordered table-striped table-condensed">
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Condition</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a class="xref" href="System.ArgumentOutOfRangeException.html#System_ArgumentOutOfRangeException">ArgumentOutOfRangeException</a></td>
                    <td><p>The <em>millisecondsTimeOutInterval</em> parameter is less than -1. </p>
</td>
                  </tr>
                </tbody>
              </table>
            </article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
            <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
            </nav>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="inner-footer">
          <p>© .NET Foundation</p>
          <p>
            <a href="https://www.github.com/dotnet" target="_blank"><span class="fa fa-stack fa-lg">
              <span class="fa fa-square-o fa-stack-2x"></span>
              <span class="fa fa-github fa-stack-1x"></span>
            </span></a>
            <a href="https://twitter.com/dotnet" target="_blank"><span class="fa fa-stack fa-lg">
              <span class="fa fa-square-o fa-stack-2x"></span>
              <span class="fa fa-twitter fa-stack-1x"></span>
            </span></a>
            <a href="https://www.facebook.com/dotnet" target="_blank"><span class="fa fa-stack fa-lg">
              <span class="fa fa-square-o fa-stack-2x"></span>
              <span class="fa fa-facebook fa-stack-1x"></span>
            </span></a>
      
          </p>
          </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
